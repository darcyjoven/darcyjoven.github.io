[{"categories":["软件安装"],"content":" graph LR subgraph 6.服务端验证完毕: end subgraph 5.客户端发送验证后资料: j[\"客户端\"]--私钥解密--\u003ek[\"服务端\"] end subgraph 4.客户端请求服务段验证: e[\"服务端\"]--随机数据--\u003eg[\"客户端\"] end subgraph 3.客户端访问客户端: d[\"客户端\"]--\u003ef[\"服务端\"] end subgraph 2.私钥放到服务端: h[\"私钥\"]--放置--\u003ei[\"服务端\"] end subgraph 1.产生密钥: a[\"客户端\"]--生成--\u003eb[\"公钥\"] a--生成--\u003ec[\"私钥\"] end 产生ssh密钥 #产生ssh密钥 \u003e ssh-keygen Generating public/private rsa key pair. Enter file in which to save the key (C:\\Users\\darcy/.ssh/id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in C:\\Users\\darcy/.ssh/id_rsa Your public key has been saved in C:\\Users\\darcy/.ssh/id_rsa.pub The key fingerprint is: SHA256:NezN7f4OQQ183iHvX17y6QLijOTIDoWzhozgvo/tras darcy@darcy The key's randomart image is: +---[RSA 3072]----+ | .. | | . ..+.| | + +o+| | . o + o .o| |. o . S . o + | |= . + . . . ..oo| |.+ +. + + . . o+=| |. + oo o o o o+| | E=*+o ++o| +----[SHA256]-----+ ","date":"2023年 11月15日","objectID":"/ssh%E5%AF%86%E9%92%A5%E4%BD%BF%E7%94%A8/:0:0","tags":["ssh","远程开发"],"title":"ssh密钥使用","uri":"/ssh%E5%AF%86%E9%92%A5%E4%BD%BF%E7%94%A8/"},{"categories":["软件安装","软件使用"],"content":"windows 安装 RUST 官网下载 rustup-init.exe，linux系统按照sh文件安装 (https://www.rust-lang.org/)[https://www.rust-lang.org/] 不安装多余文件，选择3然后安装RUSTUP。 安装默认cargo 检查是否安装成功 安装mdbook cargo install mdbook 以上为windows安装方式，发现安装时缺少很多文件，放弃，因为不想用mdbook需要安装一个vs。后面是linux 的教程，系统是ubuntu。 rustup self uninstall，卸载已安装的rustup linux 安装 安装rust 安装mdbook cargo install mdbook WSL2 使用本机proxy export ALL_PROXY=“http://192.168.1.1:7890” 192.168.1.1是本机的IP 在需要的目录初始化mdbook mdbook init ","date":"2023年 11月15日","objectID":"/mdbook%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B/:0:0","tags":["rust","mdbook"],"title":"mdbook安装过程","uri":"/mdbook%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B/"},{"categories":["软件安装","软件使用"],"content":"mdbook 使用 mdbook build 发布为html，默认为book目录 dbook build --dest-dir**** 指定目的文件夹 mkbook watch 实时转为html mkbook serve 打开网页服务，并实时显示 mkbook clean 清除已build的内容 ","date":"2023年 11月15日","objectID":"/mdbook%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B/:1:0","tags":["rust","mdbook"],"title":"mdbook安装过程","uri":"/mdbook%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B/"},{"categories":["软件安装","软件使用"],"content":"mermaid 插件安装 cargo install mdbook-mermaid 安装到要使用的目录 mdbook-mermaid install ./ 额外语言支持 theme/highlight.js 使用此文件替换mdbook默认文件 ","date":"2023年 11月15日","objectID":"/mdbook%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B/:1:1","tags":["rust","mdbook"],"title":"mdbook安装过程","uri":"/mdbook%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B/"},{"categories":["编程问题"],"content":" 断言—接口断言为确定类型 var greeting interface{} = \"hello world\" greetingStr := greeting.(string) 类型转换—底层结构一致的类型相互转换 greeting := []byte(\"hello world\") greetingStr := string(greeting) ","date":"2023年 11月15日","objectID":"/go-inteface/:0:0","tags":["golang"],"title":"go 类型转换与断言","uri":"/go-inteface/"},{"categories":["BDL教学"],"content":"模组清单 模组看起来很多，常用的只有下面几个： AAP 应付账款 ABM 产品结构系统 产品BOM结构 AEC 工艺与工作站系统 产品的工艺资料 AGL 总账会计 AIM 库存料件资料管理系统 AOO 整体系统管理 APM 采购管理 ANM 票据资金 AQC 质量管理 ASF 生产管理 AWS 集成管理 AXC 成本管理 AXM 销售管理 AXR 应收账款 AZZ 系统管理 SUB 一般副程序 LIB 公用程序 GAP 应付账款管理系统大陆版 模组编号A变为C，就变成了客制模组，客制添加的作业一般在客制模组。 如果模组第一个字母不是A，是直接加C，如CSUB、CLIB、CGAP。 ","date":"2023年 11月15日","objectID":"/erptiptop%E5%AF%B9%E8%B1%A1%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/:1:0","tags":["oracle","sql","bdl"],"title":"ERP（TIPTOP）对象命名规则","uri":"/erptiptop%E5%AF%B9%E8%B1%A1%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/"},{"categories":["BDL教学"],"content":"作业类型编码 不同类型的作业可以分为以下几类： 单档录入作业：i 单档参数作业：s 双档录入作业：t 查询作业：q 报表作业：r 批处理作业：p ","date":"2023年 11月15日","objectID":"/erptiptop%E5%AF%B9%E8%B1%A1%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/:2:0","tags":["oracle","sql","bdl"],"title":"ERP（TIPTOP）对象命名规则","uri":"/erptiptop%E5%AF%B9%E8%B1%A1%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/"},{"categories":["BDL教学"],"content":"程序命名规则 程序一般为4为字母和3为流水码组成。（部分模组为了让开发者更好记住，不是这样命名，如p_zz，p_zx，p_zxw这些都是azz模组下的作业，不按照此命名方式命名） 例如： aooi040 —\u003e aoo是模组的名称，i 是作业类型编号，040 是流水号。 这个作业是aoo整体系统管理模组下的一个单档可录入资料的作业。 ","date":"2023年 11月15日","objectID":"/erptiptop%E5%AF%B9%E8%B1%A1%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/:3:0","tags":["oracle","sql","bdl"],"title":"ERP（TIPTOP）对象命名规则","uri":"/erptiptop%E5%AF%B9%E8%B1%A1%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/"},{"categories":["BDL教学"],"content":"数据库命名规则 ","date":"2023年 11月15日","objectID":"/erptiptop%E5%AF%B9%E8%B1%A1%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/:4:0","tags":["oracle","sql","bdl"],"title":"ERP（TIPTOP）对象命名规则","uri":"/erptiptop%E5%AF%B9%E8%B1%A1%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/"},{"categories":["BDL教学"],"content":"数据库表名规则 数据库表名分为表名和固定后缀两个部分，ERP中所有正式表（在p_zta中注册的表）都有固定的后缀（_file）。 标准表 标准表的表名是三位字母，这是鼎捷出场就建立好的表。我们不会去动这些表名。 如工单单头表名：sfb_file 客制表 后续客制添加的表名是以tc_ 固定前缀，和三位字母加上固定的后缀_file 组成的。 例如你要客制一个表，可以用tc_sfb_file，这样的方式命名。其中tc_与_file都是固定的只有三位字母需要自己取名。 ","date":"2023年 11月15日","objectID":"/erptiptop%E5%AF%B9%E8%B1%A1%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/:4:1","tags":["oracle","sql","bdl"],"title":"ERP（TIPTOP）对象命名规则","uri":"/erptiptop%E5%AF%B9%E8%B1%A1%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/"},{"categories":["BDL教学"],"content":"数据库表字段规则 数据库的表字段也是由两部分组成 表名+流水码。 标准表的标准字段 流水码一般为2为流水码，有时候字段多，可以用多维流水码或者字母，这个限制不是太死。一般是2位流水码。 例如：工单单号字段 sfb01，看名称sfb就是表名，这个字段是sfb_file表的一个字段，01是流水码。 标准表的客制字段 如果标准表中的字段不够用，可以增加字段，增加的字段叫做客制字段。 客制字段需要在字段前加固定前缀****ta_，例如：sfb_file表中增加客制字段用来记录备注，可以命名为ta_sfb01 客制表的字段 客制表的字段也是表名+流水码，例如tc_sfb01，tc_sfb02 字段 undefine 在标准表中有一些定义了但是没有使用的字段，例如：sfbud01，sfbud02，这些字段定义了但是没有存储数据，我们后面可以使用这些字段。 当ud字段数量不够时，可以在增加ta_sfb01，ta_sfb02这些客制字段。 ","date":"2023年 11月15日","objectID":"/erptiptop%E5%AF%B9%E8%B1%A1%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/:4:2","tags":["oracle","sql","bdl"],"title":"ERP（TIPTOP）对象命名规则","uri":"/erptiptop%E5%AF%B9%E8%B1%A1%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/"},{"categories":["软件安装","软件使用"],"content":" git stash 是储藏的意思 本地代码落后远程一此commit，但是本地又修改了代码，不希望本地增加一次提交，可以使用git stash。 git stash 是将本地修改的内容暂时保存，当远程同步后，再将暂时保存的内容取出修改。 git stash pop 取出最近一次暂存代码 再次查看已经没有差异 ","date":"2023年 11月15日","objectID":"/git-stash/:0:0","tags":["git"],"title":"git stash 使用","uri":"/git-stash/"},{"categories":["编程问题"],"content":" // 一次性写入 if err := os.WriteFile(\"file.txt\", []byte(\"Hello GOSAMPLES!\"), 0666); err != nil { log.Fatal(err) } // 逐行写入 package main import ( \"log\" \"os\" ) var lines = []string{ \"Go\", \"is\", \"the\", \"best\", \"programming\", \"language\", \"in\", \"the\", \"world\", } func main() { // create file f, err := os.Create(\"file.txt\") if err != nil { log.Fatal(err) } // remember to close the file defer f.Close() for _, line := range lines { _, err := f.WriteString(line + \"\\n\") if err != nil { log.Fatal(err) } } } // 写入byte package main import ( \"log\" \"os\" ) var bytes = []byte{ 0x47, // G 0x4f, // O 0x20, // \u003cspace\u003e 0x20, // \u003cspace\u003e 0x20, // \u003cspace\u003e 0x50, // P 0x4c, // L 0x45, // E 0x53, // S } var additionalBytes = []byte{ 0x53, // S 0x41, // A 0x4d, // M } func main() { // create file f, err := os.Create(\"file.txt\") if err != nil { log.Fatal(err) } // remember to close the file defer f.Close() // write bytes to the file _, err = f.Write(bytes) if err != nil { log.Fatal(err) } // write additional bytes to the file, start at index 2 _, err = f.WriteAt(additionalBytes, 2) if err != nil { log.Fatal(err) } } // 缓冲方式写入 package main import ( \"bufio\" \"log\" \"os\" ) var lines = []string{ \"Go\", \"is\", \"the\", \"best\", \"programming\", \"language\", \"in\", \"the\", \"world\", } func main() { // create file f, err := os.Create(\"file.txt\") if err != nil { log.Fatal(err) } // remember to close the file defer f.Close() // create new buffer buffer := bufio.NewWriter(f) for _, line := range lines { _, err := buffer.WriteString(line + \"\\n\") if err != nil { log.Fatal(err) } } // flush buffered data to the file if err := buffer.Flush(); err != nil { log.Fatal(err) } } ","date":"2023年 11月15日","objectID":"/golang-write/:0:0","tags":["golang","文件系统"],"title":"golang的文件写入","uri":"/golang-write/"},{"categories":["数据库运维"],"content":"假设存在两个表： createtabledarcy1(ima01varchar(40),ima02varchar(40),ima021varchar(200));createtabledarcy2(ima01varchar(40),ima02varchar(40)) 运行下面代码不会出错，darcy2虽然没有ima021字段，但是SQL能匹配到darcy1有ima021字段，所以ima021字段被省略了。 select*fromdarcy1where(ima01,ima02,ima021)in(selectima01,ima02,ima021fromdarcy2whereima01like'M%') 以上代码结果等价于： select*fromdarcy1where(ima01,ima02)in(selectima01,ima02fromdarcy2whereima01like'M%') 所以嵌套的时候，如果两个表字段有可能重复，子查询中请尽量用表名.字段的形式。 ","date":"2023年 11月15日","objectID":"/sql-in-error/:0:0","tags":["oracle","sql","运维"],"title":"in嵌套错误字段问题","uri":"/sql-in-error/"},{"categories":["数据库运维"],"content":"最近运行平均时间较长SQL查询 select*from(selectsa.SQL_TEXT,sa.SQL_FULLTEXT,sa.EXECUTIONS\"执行次数\",round(sa.ELAPSED_TIME/1000000,2)\"总执行时间\",round(sa.ELAPSED_TIME/1000000/sa.EXECUTIONS,2)\"平均执行时间\",sa.COMMAND_TYPE,sa.PARSING_USER_ID\"用户ID\",u.username\"用户名\",sa.HASH_VALUEfromv$sqlareasaleftjoinall_usersuonsa.PARSING_USER_ID=u.user_idwheresa.EXECUTIONS\u003e0orderby(sa.ELAPSED_TIME/sa.EXECUTIONS)desc)whererownum\u003c=50; ","date":"2023年 11月15日","objectID":"/oracle-run-sql/:1:0","tags":["oracle","sql"],"title":"oracle最近运行SQL查询","uri":"/oracle-run-sql/"},{"categories":["数据库运维"],"content":"最近运行SQL查询 SELECT*fromV$SQLWHEREsql_idISNOTNULL; ","date":"2023年 11月15日","objectID":"/oracle-run-sql/:2:0","tags":["oracle","sql"],"title":"oracle最近运行SQL查询","uri":"/oracle-run-sql/"},{"categories":null,"content":"关于 LoveIt","date":"2019年 08月02日","objectID":"/about/","tags":null,"title":"关于 LoveIt","uri":"/about/"},{"categories":null,"content":"@darcyjoven 👋 🔭 I’m currently working at Forewin a company in suzhou.jiangsu.China 💬 Ask me about golang,fgl genero,ERP,javascript… 🖥 My blog site is: darcy’s blog 📘 My book site is: darcy’s book 📫 How to reach me: ✉ darcy_joven@live.com 📱 wechat:darcy_joven ","date":"2019年 08月02日","objectID":"/about/:0:0","tags":null,"title":"关于 LoveIt","uri":"/about/"}]