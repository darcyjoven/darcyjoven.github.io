[{"categories":["ERP问题"],"content":"接口的DEBUG ","date":"2023年 12月12日","objectID":"/debug-in-webservice/:0:0","tags":["erp","bdl","debug"],"title":"接口的DEBUG","uri":"/debug-in-webservice/"},{"categories":["ERP问题"],"content":"前提 普通作业的debug你已经会使用，后面会出一篇普通debug的使用。 ","date":"2023年 12月12日","objectID":"/debug-in-webservice/:1:0","tags":["erp","bdl","debug"],"title":"接口的DEBUG","uri":"/debug-in-webservice/"},{"categories":["ERP问题"],"content":"事先准备 下载可以抛砖测试的api测试软件，如soapui、postman这些软件，只要能抛转都可以用。 tiptop gp 的webservice 建议使用soapui比较方便，T100的Restful使用postman比较方便。 ","date":"2023年 12月12日","objectID":"/debug-in-webservice/:2:0","tags":["erp","bdl","debug"],"title":"接口的DEBUG","uri":"/debug-in-webservice/"},{"categories":["ERP问题"],"content":"软件配置 点击OK后，系统会自动产生对应的接口信息，如果未产生，请检查接口服务是否启动 ","date":"2023年 12月12日","objectID":"/debug-in-webservice/:3:0","tags":["erp","bdl","debug"],"title":"接口的DEBUG","uri":"/debug-in-webservice/"},{"categories":["ERP问题"],"content":"soap ui使用 点击你要测试的接口 ERP函数名称和接口名称对应关系可以在aws_ttcfg2中查到 这里要注意的是，\u003c要替换为\u0026lt; \u003c![CDATA[…]]\u003e 中的\u003c 不需要替换，因为已经转义过一次 点击运行，就能模拟一次正常的接口请求。 ","date":"2023年 12月12日","objectID":"/debug-in-webservice/:4:0","tags":["erp","bdl","debug"],"title":"接口的DEBUG","uri":"/debug-in-webservice/"},{"categories":["ERP问题"],"content":"DEBUG ERP程序 ","date":"2023年 12月12日","objectID":"/debug-in-webservice/:5:0","tags":["erp","bdl","debug"],"title":"接口的DEBUG","uri":"/debug-in-webservice/"},{"categories":["ERP问题"],"content":"指定断点 ERP的webservice程序为aws_ttsrv2，做过客制的话有可能是其它作业。 和正常作业一样，我们使用r.d2+ aws_ttsrv2进入到debug页面 我们在debug命令窗口，指定我们想要停止的断点，一般用我们需要停止的函数做断点即可。 ","date":"2023年 12月12日","objectID":"/debug-in-webservice/:5:1","tags":["erp","bdl","debug"],"title":"接口的DEBUG","uri":"/debug-in-webservice/"},{"categories":["ERP问题"],"content":"指定端口 断点指定好之后，我们需要指定一个端口用来测试，端口编号只要没有被占用即可 点击OK之后，我们就进入到了等待服务需求状态，这个时候debug会一直转圈等待。 ","date":"2023年 12月12日","objectID":"/debug-in-webservice/:5:2","tags":["erp","bdl","debug"],"title":"接口的DEBUG","uri":"/debug-in-webservice/"},{"categories":["ERP问题"],"content":"soap ui指定端口 我们将soap ui中的地址改为和debug一致的端口，然后点击提交。 这个时候debug会进入到断点处，我们开始和正常程序一样debug即可。如果需要重新抛转，在debug中点击允许，soap ui重新抛转一次，就可以在回到断点处。 ","date":"2023年 12月12日","objectID":"/debug-in-webservice/:6:0","tags":["erp","bdl","debug"],"title":"接口的DEBUG","uri":"/debug-in-webservice/"},{"categories":["ERP问题"],"content":" VPN和内部的网络访问只能是路由或是交换的方式，不能做NAT 客户端telnet到服务器后，在服务器端通过 echo $FGLSERVER 指令可以看到客户端VPN的IP 从服务器发起 ping / trace 到客户端VPN的IP可以正常访问 从服务器发起 telnet 客户端VPN的IP的 6400 端口可以正常访问 目前对客户端电脑的环境要求是Windows xp，Windows 7、8 ，IE版本8及以上，并且以管理员身份进入操作系统，其中IE11要设置兼容性设置，另外对于报表打印或者文档汇出，需要做如下设定： 设置IE为默认浏览器 把ERP网址和CR网址都加入到受信任站点，将受信任安全级别调到最低 如果无法弹出网页，请尝试关闭防火墙以及其他杀毒软件 ","date":"2023年 11月16日","objectID":"/erp%E7%BD%91%E7%BB%9C%E9%9C%80%E6%B1%82/:0:0","tags":["erp","运维","tiptop gp","T100"],"title":"ERP网络需求","uri":"/erp%E7%BD%91%E7%BB%9C%E9%9C%80%E6%B1%82/"},{"categories":["编程问题"],"content":"引入fglExt.h头文件 fglExt.h 在$FGLDIR/include/f2c目录下，我们需要用到暴露函数的结构体UsrFunction和出栈popvchar入栈pushvchar函数。 返回值和参数值不同类型请用不同的出栈入栈函数，popint、pushint等 以下示例，使用C语言新增函数base64Decode、base64Encode，用来base64格式的编码和解码。 ","date":"2023年 11月16日","objectID":"/bdl%E8%B0%83%E7%94%A8c%E8%AF%AD%E8%A8%80%E5%8A%A8%E6%80%81%E5%BA%93.so/:1:0","tags":["c语言","linux","bdl"],"title":"BDL调用C语言动态库.so","uri":"/bdl%E8%B0%83%E7%94%A8c%E8%AF%AD%E8%A8%80%E5%8A%A8%E6%80%81%E5%BA%93.so/"},{"categories":["编程问题"],"content":"编写代码 ","date":"2023年 11月16日","objectID":"/bdl%E8%B0%83%E7%94%A8c%E8%AF%AD%E8%A8%80%E5%8A%A8%E6%80%81%E5%BA%93.so/:2:0","tags":["c语言","linux","bdl"],"title":"BDL调用C语言动态库.so","uri":"/bdl%E8%B0%83%E7%94%A8c%E8%AF%AD%E8%A8%80%E5%8A%A8%E6%80%81%E5%BA%93.so/"},{"categories":["编程问题"],"content":"项目结构 为了方便后期维护，我将功能函数和函数暴露定义放在量个文件中，如下所示。 base64.c base64ext.c 功能函数就是实际处理逻辑，功能暴露函数定义了运行中传参、返回值个数、需要暴露的函数名称等参数。 为了后续可以增加多个函数，所以将暴露函数文件单独写。后面要引入其它功能函数，直接在这个文件中添加即可。实际你写在一个文件中也是没问题的。 c代码路径 源代码的路径可以在服务器任何位置，只要在服务器能够编译即可。 ","date":"2023年 11月16日","objectID":"/bdl%E8%B0%83%E7%94%A8c%E8%AF%AD%E8%A8%80%E5%8A%A8%E6%80%81%E5%BA%93.so/:2:1","tags":["c语言","linux","bdl"],"title":"BDL调用C语言动态库.so","uri":"/bdl%E8%B0%83%E7%94%A8c%E8%AF%AD%E8%A8%80%E5%8A%A8%E6%80%81%E5%BA%93.so/"},{"categories":["编程问题"],"content":"逻辑函数 我的代码中主要函数是这两个，一个编码一个解码，若要希望BDL能直接调用，需要封装一下。 char* base64_decode(const char* str); char* base64_encode(const char* str); 函数的签名为int func(int);，此函数返回的是返回值数量，参数为BDL调用时的数量。 int base64Encode(int in_num){ const int sz = 5000; char src[sz]; char *ret; // assert需导入断言库\u003cassert.h\u003e，可以不用 assert(in_num==1); // 取参数 // popvchar取出当前栈最上面的参数，需导入头文件\"f2c/fglExt.h\"，才能使用 // 如果有多个参数，第一次取得值是最后一个参数，后入先出 popvchar(src,sz); if (*src == '\\\\0') { // pushvchar 返回值，如果有两个返回值，则调用两次pushvchar pushvchar(\"\", 0); return 1; } ret = base64_encode(src); pushvchar(ret, strlen(ret)); return 1; } ","date":"2023年 11月16日","objectID":"/bdl%E8%B0%83%E7%94%A8c%E8%AF%AD%E8%A8%80%E5%8A%A8%E6%80%81%E5%BA%93.so/:2:2","tags":["c语言","linux","bdl"],"title":"BDL调用C语言动态库.so","uri":"/bdl%E8%B0%83%E7%94%A8c%E8%AF%AD%E8%A8%80%E5%8A%A8%E6%80%81%E5%BA%93.so/"},{"categories":["编程问题"],"content":"向外暴露函数 处理逻辑处理，还需要向外部暴露函数。base64ext.c 暴露函数得时候，使用一个结构体UsrFunction数组，其中： 是结束标志，必须以这个结束 每一行都是向BDL暴露一个函数 第一个参数为暴露得函数名，即BDL中要调用得名字 int func(int) 第三个参数为参数数量 第四个参数为返回值数量 ，表示数量可以变 #include \"f2c/fglExt.h\" // 申明函数签名 int base64Encode(int); int base64Decode(int); UsrFunction usrFunctions[]={ { \"base64Decode\", base64Decode, 1, 1 }, { \"base64Encode\", base64Encode, 1, 1 }, { 0,0,0,0 } }; ","date":"2023年 11月16日","objectID":"/bdl%E8%B0%83%E7%94%A8c%E8%AF%AD%E8%A8%80%E5%8A%A8%E6%80%81%E5%BA%93.so/:2:3","tags":["c语言","linux","bdl"],"title":"BDL调用C语言动态库.so","uri":"/bdl%E8%B0%83%E7%94%A8c%E8%AF%AD%E8%A8%80%E5%8A%A8%E6%80%81%E5%BA%93.so/"},{"categories":["编程问题"],"content":"编译 编译c源文件 gcc -c -I $FGLDIR/include -fPIC base64.c gcc -c -I $FGLDIR/include -fPIC base64ext.c 此步将在当前目录产生对应的.o文件。 链接为so文件 gcc -shared -o libbase64.so base64.o base64ext.o -L$FGLDIR/lib -lfgl 此步产生so文件，so文件是我们运行时需要的文件，其它文件运行时都不需要。 so文件移动到$FGLLDPATH的目录中 $FGLLDPATH目录可以在$TOP/bin/tiptop_env文件中设置，所有的42m目录都在$FGLLDPATH中。 ","date":"2023年 11月16日","objectID":"/bdl%E8%B0%83%E7%94%A8c%E8%AF%AD%E8%A8%80%E5%8A%A8%E6%80%81%E5%BA%93.so/:3:0","tags":["c语言","linux","bdl"],"title":"BDL调用C语言动态库.so","uri":"/bdl%E8%B0%83%E7%94%A8c%E8%AF%AD%E8%A8%80%E5%8A%A8%E6%80%81%E5%BA%93.so/"},{"categories":["编程问题"],"content":"调用 在BDL中只要importhi后即可使用这两个函数。 importlibbase64functionmain()definestr1,str2varchar(100)callbase64Encode(\"Hello World!\")returningstr1callbase64Decode(str1)returningstr2display\"\"display\"str1 is \"||str1display\"str2 is \"||str2endfunction ","date":"2023年 11月16日","objectID":"/bdl%E8%B0%83%E7%94%A8c%E8%AF%AD%E8%A8%80%E5%8A%A8%E6%80%81%E5%BA%93.so/:4:0","tags":["c语言","linux","bdl"],"title":"BDL调用C语言动态库.so","uri":"/bdl%E8%B0%83%E7%94%A8c%E8%AF%AD%E8%A8%80%E5%8A%A8%E6%80%81%E5%BA%93.so/"},{"categories":["编程问题"],"content":"源码 base64.c #include \u003cstdio.h\u003e#include \u003cstring.h\u003e#include \u003cstdlib.h\u003e#include \u003cassert.h\u003e#include \"f2c/fglExt.h\" char* base64_decode(const char* str); char* base64_encode(const char* str); int base64Encode(int); int base64Decode(int); char* base64_decode(const char* str){ unsigned char imap[79]={62,0,0,0,63,52,53,54,55,56,57,58,59,60,61,0,0,0,0,0,0,0,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,0,0,0,0,0,0,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50}; int rest_count =0; int buf_idx=0; int len = strlen(str); int flen = len; int i; while(str[flen-1]=='=') flen--; int buflen = flen*6/8+1; unsigned char* buf = (unsigned char*) malloc(buflen); memset(buf,'\\\\0',buflen); for(i=0;i\u003cflen;i++){ unsigned char c=imap[str[i]-43]; int mcount = rest_count ==0?-2:6-rest_count; unsigned char c0 = (mcount\u003e0?c\u003e\u003emcount:c\u003c\u003c-mcount); buf[buf_idx] = buf[buf_idx] | c0; rest_count= mcount \u003c0 ? -mcount : 8-mcount; if(mcount\u003e=0) buf[++buf_idx]=c\u003c\u003crest_count; } return buf; } char* base64_encode(const char* str){ char map[65]=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"; int len =strlen(str); int buflen = len * 8 / 6 + 4;//缺位补齐1 俩等号2 最后0-1位 unsigned char* buf = (unsigned char*)malloc(buflen); memset(buf,'\\\\0',buflen); char a [4]; int i; int rest_count = 0; int index = 0; int buf_idx =0 ; unsigned char last = 0; for( i=0;i\u003clen;i++){ unsigned char c = str[i]; a[index]= (last\u003c\u003c(6-rest_count))\u002663; int get_count = 6-rest_count; a[index] = a[index] | ( c \u003e\u003e(8-get_count)); a[index]=map[a[index]]; rest_count = 8-get_count; last = c; index = index==2?0:index+1; if(index==0){ a[3]=map[c\u002663]; memcpy(buf+buf_idx,a,4); buf_idx+=4; rest_count=0; last = 0; } } if(index!=0){ a[index]= last\u003c\u003c(6-rest_count) \u0026 63; a[index]=map[a[index]]; memcpy(buf+buf_idx,a,index+1); buf[buf_idx+index+1]='='; buf[buf_idx+index+2]= rest_count ==2 ? '=':0; } return buf; } int base64Encode(int in_num){ const int sz = 5000; char src[sz]; char *ret; int *p; assert(in_num==1); // 取参数 popvchar(src,sz); if (*src == '\\\\0') { pushvchar(\"\", 0); return 1; } ret = base64_encode(src); pushvchar(ret, strlen(ret)); return 1; } int base64Decode(int in_num){ const int sz = 5000; char src[sz]; char *ret; int *p; assert(in_num == 1); // 取参数 popvchar(src,sz); if (*src == '\\\\0') { pushvchar(\"\", 0); return 1; } ret = base64_decode(src); pushvchar(ret, strlen(ret)); return 1; } base64ext.c #include \"f2c/fglExt.h\" int base64Encode(int); int base64Decode(int); UsrFunction usrFunctions[]={ { \"base64Decode\", base64Decode, 1, 1 }, { \"base64Encode\", base64Encode, 1, 1 }, { 0,0,0,0 } }; ","date":"2023年 11月16日","objectID":"/bdl%E8%B0%83%E7%94%A8c%E8%AF%AD%E8%A8%80%E5%8A%A8%E6%80%81%E5%BA%93.so/:5:0","tags":["c语言","linux","bdl"],"title":"BDL调用C语言动态库.so","uri":"/bdl%E8%B0%83%E7%94%A8c%E8%AF%AD%E8%A8%80%E5%8A%A8%E6%80%81%E5%BA%93.so/"},{"categories":["编程问题"],"content":"fgl BDL调用dll库 ","date":"2023年 11月16日","objectID":"/bdl%E8%B0%83%E7%94%A8dll%E5%BA%93/:0:0","tags":["bdl","dll","so","c语言","linux","tiptop gp","T100"],"title":"BDL调用dll库","uri":"/bdl%E8%B0%83%E7%94%A8dll%E5%BA%93/"},{"categories":["编程问题"],"content":"MAC 和LINUX 原则上都支持 .dyLib 和 .so 都支持，因为用户较少所以未测试。 ","date":"2023年 11月16日","objectID":"/bdl%E8%B0%83%E7%94%A8dll%E5%BA%93/:1:0","tags":["bdl","dll","so","c语言","linux","tiptop gp","T100"],"title":"BDL调用dll库","uri":"/bdl%E8%B0%83%E7%94%A8dll%E5%BA%93/"},{"categories":["编程问题"],"content":"利用vs开发 在新建项目中选择此项 ","date":"2023年 11月16日","objectID":"/bdl%E8%B0%83%E7%94%A8dll%E5%BA%93/:2:0","tags":["bdl","dll","so","c语言","linux","tiptop gp","T100"],"title":"BDL调用dll库","uri":"/bdl%E8%B0%83%E7%94%A8dll%E5%BA%93/"},{"categories":["编程问题"],"content":"新增头文件 文件名随意，以下代码申明了需要的数据结构，调用时，通过此struct进行传参和接受回传。 #pragma once struct frontEndInterface { short (*getParamCount) (); short (*getReturnCount) (); void (*popInteger) (long\u0026, short\u0026); void (*pushInteger) (const long, short); void (*popString) (char*, short\u0026, short\u0026); void (*pushString) (const char*, short, short); void (*getFrontEndEnv) (const char*, char*, short\u0026); void (*popWString) (wchar_t*, short\u0026, short\u0026); void (*pushWString) (const wchar_t*, short, short); }; #ifdef WIN32 #define EXPORT extern \"C\" __declspec(dllexport) #else #define EXPORT extern \"C\" #endif // 下面时你要实现的函数。 EXPORT void initialize(); EXPORT void finalize(); EXPORT int mysum(const frontEndInterface\u0026 fx); ","date":"2023年 11月16日","objectID":"/bdl%E8%B0%83%E7%94%A8dll%E5%BA%93/:3:0","tags":["bdl","dll","so","c语言","linux","tiptop gp","T100"],"title":"BDL调用dll库","uri":"/bdl%E8%B0%83%E7%94%A8dll%E5%BA%93/"},{"categories":["编程问题"],"content":"编写实现函数 需要导入刚才完成的头文件，我这里是#include \"erpdemo.h\"。 // dllmain.cpp : 定义 DLL 应用程序的入口点。 #include \"pch.h\"#include \"erpdemo.h\"#include \u003cstdio.h\u003e#include \u003cstring.h\u003e/* BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved ) { switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; } return TRUE; } 这部分为vs自动生成。 */ void initialize() { } void finalize() { } int mysum(const struct frontEndInterface\u0026 fci) { long param1, param2; short isNull1, isNull2; long sum; char msg[255]; if (fci.getParamCount() != 2 || fci.getReturnCount() != 2) { return -1; } fci.popInteger(param2, isNull2); fci.popInteger(param1, isNull1); sum = param1 + param2; if (!isNull1 \u0026\u0026 !isNull2) { sum = param1 + param2; sprintf_s(msg, \"%d + %d = %d\", param1, param2, sum); } else { sum = 0; sprintf_s(msg, \"Parameters are NULL\"); } fci.pushInteger(sum, 0); fci.pushString(msg, strlen(msg), 0); return 0; } ","date":"2023年 11月16日","objectID":"/bdl%E8%B0%83%E7%94%A8dll%E5%BA%93/:4:0","tags":["bdl","dll","so","c语言","linux","tiptop gp","T100"],"title":"BDL调用dll库","uri":"/bdl%E8%B0%83%E7%94%A8dll%E5%BA%93/"},{"categories":["编程问题"],"content":"debug时会生成dll文件，将文件拷贝到gdc所在目录 ","date":"2023年 11月16日","objectID":"/bdl%E8%B0%83%E7%94%A8dll%E5%BA%93/:5:0","tags":["bdl","dll","so","c语言","linux","tiptop gp","T100"],"title":"BDL调用dll库","uri":"/bdl%E8%B0%83%E7%94%A8dll%E5%BA%93/"},{"categories":["编程问题"],"content":"BDL 调用 -- erpdemo 为dll名 -- mysum 为调用的函数名 -- [100,250] 为参数列表 -- [res,msg] 为回传的结果 CALLui.Interface.frontCall(\"erpdemo\",\"mysum\",[100,250],[res,msg]) ","date":"2023年 11月16日","objectID":"/bdl%E8%B0%83%E7%94%A8dll%E5%BA%93/:6:0","tags":["bdl","dll","so","c语言","linux","tiptop gp","T100"],"title":"BDL调用dll库","uri":"/bdl%E8%B0%83%E7%94%A8dll%E5%BA%93/"},{"categories":["编程问题"],"content":"golang 编译 package main import \"C\" import \"fmt\" //export hello func hello(){ fmt.Println(\"hello world\") } //export add func add(a,b int) int { return a+b } func main(){ } golang中要导出的函数前要增加备注//export hello，且必须写有main函数。 import \"C\"也是必须导入的。 使用命令 go build -buildmode=c-shared -o xxx.so yyy 进行编译产生.so和.h文件，其中xxx是.so的文件名，yyy是项目名称。 如果编译之后未产生.h 文件，说明没有导出任何函数，请检查go源码。 编译产生的.so文件运行时需要，需要加载到$FGLDIR/lib目录下，也可以ln -s创建软链接。 ","date":"2023年 11月16日","objectID":"/bdl%E8%B0%83%E7%94%A8golangcgo/:1:0","tags":["golang","c语言","tiptop gp","T100","so"],"title":"BDL调用golang(cgo)","uri":"/bdl%E8%B0%83%E7%94%A8golangcgo/"},{"categories":["编程问题"],"content":"C语言封装 BDL调用C语言可以见BDL调用C语言 源码如下： #include \u003cstdio.h\u003e#include \"f2c/fglExt.h\"#include \"libsum.h\" int sum(int); GoInt Sum(GoInt,GoInt); UsrFunction usrFunctions[]={ { \"sum\", sum, 2, 1 }, { 0,0,0,0 } }; int sum(int in_num){ int s,a=0,b=0; popint(\u0026a); popint(\u0026b); s = Sum(a,b); pushint(s); return 1; } 产生.o 文件 gcc -c -I $FGLDIR/include -fPIC demo.c 产生.so文件 gcc -shared -o libsuma.so demo.o -L $FGLDIR/lib -lfgl -lsum 将产生的.so文件放到$FGLLDPATH的路径中 ","date":"2023年 11月16日","objectID":"/bdl%E8%B0%83%E7%94%A8golangcgo/:2:0","tags":["golang","c语言","tiptop gp","T100","so"],"title":"BDL调用golang(cgo)","uri":"/bdl%E8%B0%83%E7%94%A8golangcgo/"},{"categories":["编程问题"],"content":"BDL调用 importlibsumafunctionmain()definesintegercallsum(2,3)returningsdisplaysfmt(\"\\\\n2+3=%1\",s)endfunction BDL调用时只要调用libsuma即可，libsum会在libsuma调用后自动加载。 直接调用的.so 在$FGLLDPATH目录，c调用的.so在$FGLDIR/lib目录。 ","date":"2023年 11月16日","objectID":"/bdl%E8%B0%83%E7%94%A8golangcgo/:3:0","tags":["golang","c语言","tiptop gp","T100","so"],"title":"BDL调用golang(cgo)","uri":"/bdl%E8%B0%83%E7%94%A8golangcgo/"},{"categories":["编程问题"],"content":"fgl bdl语言集成java包 ","date":"2023年 11月16日","objectID":"/fgl-bdl%E8%AF%AD%E8%A8%80%E9%9B%86%E6%88%90java%E5%8C%85/:0:0","tags":["tiptop gp","T100","java","linux"],"title":"fgl bdl语言集成java包","uri":"/fgl-bdl%E8%AF%AD%E8%A8%80%E9%9B%86%E6%88%90java%E5%8C%85/"},{"categories":["编程问题"],"content":"确保java包版本和服务器jre版本一致 java -version ","date":"2023年 11月16日","objectID":"/fgl-bdl%E8%AF%AD%E8%A8%80%E9%9B%86%E6%88%90java%E5%8C%85/:1:0","tags":["tiptop gp","T100","java","linux"],"title":"fgl bdl语言集成java包","uri":"/fgl-bdl%E8%AF%AD%E8%A8%80%E9%9B%86%E6%88%90java%E5%8C%85/"},{"categories":["编程问题"],"content":"用静态类的方法返回值 bdl不支持面向对象编程（新版本支持单功能单一），所以用java静态类返回对象或者值来代替new Person()这种构建函数。 ","date":"2023年 11月16日","objectID":"/fgl-bdl%E8%AF%AD%E8%A8%80%E9%9B%86%E6%88%90java%E5%8C%85/:2:0","tags":["tiptop gp","T100","java","linux"],"title":"fgl bdl语言集成java包","uri":"/fgl-bdl%E8%AF%AD%E8%A8%80%E9%9B%86%E6%88%90java%E5%8C%85/"},{"categories":["编程问题"],"content":"jar 包配置 任意位置都可以，推荐位置$TOP/ds4gl2/bin/javaad/jar ","date":"2023年 11月16日","objectID":"/fgl-bdl%E8%AF%AD%E8%A8%80%E9%9B%86%E6%88%90java%E5%8C%85/:3:0","tags":["tiptop gp","T100","java","linux"],"title":"fgl bdl语言集成java包","uri":"/fgl-bdl%E8%AF%AD%E8%A8%80%E9%9B%86%E6%88%90java%E5%8C%85/"},{"categories":["编程问题"],"content":"CLASSPATH 设置 在文件$TOP/bin/tiptop_env中设置 设置好CLASSPATH后重新登陆tiptop查看jar包是否在CLASSPATH中 ","date":"2023年 11月16日","objectID":"/fgl-bdl%E8%AF%AD%E8%A8%80%E9%9B%86%E6%88%90java%E5%8C%85/:4:0","tags":["tiptop gp","T100","java","linux"],"title":"fgl bdl语言集成java包","uri":"/fgl-bdl%E8%AF%AD%E8%A8%80%E9%9B%86%E6%88%90java%E5%8C%85/"},{"categories":["编程问题"],"content":"BDL调用JAVA代码 代码最顶部导入要使用的类 IMPORT JAVA com.alibaba.fastjson.JSON IMPORT JAVA com.alibaba.fastjson.JSONArray IMPORT JAVA com.alibaba.fastjson.JSONObject 实际调用 // 定义java类型 DEFINE json_str RECORD cust_num INTEGER, cust_name VARCHAR(30), order_ids JSONArray, arr_list JSONArray END RECORD DEFINE json_obj JSONObject LET js = '{\"cust_num\":123,\"cust_name\":\"caozq\",\"order_ids\":[234,567,789],\"arr_list\":[{\"aa\":\"aa\",\"bb\":\"cc\"},{\"aa\":\"aa1\",\"bb\":\"bb1\"}]}' // 访问静态函数 LET json_obj = com.alibaba.fastjson.JSON.parseObject(js) // 访问对象属性 LET json_str.cust_num = json_obj.getIntValue(\"cust_num\") LET json_str.cust_name = json_obj.getString(\"cust_name\") ","date":"2023年 11月16日","objectID":"/fgl-bdl%E8%AF%AD%E8%A8%80%E9%9B%86%E6%88%90java%E5%8C%85/:5:0","tags":["tiptop gp","T100","java","linux"],"title":"fgl bdl语言集成java包","uri":"/fgl-bdl%E8%AF%AD%E8%A8%80%E9%9B%86%E6%88%90java%E5%8C%85/"},{"categories":["系统运维","编程问题"],"content":"效能常规处理方法 ","date":"2023年 11月16日","objectID":"/%E6%95%88%E8%83%BD%E5%B8%B8%E8%A7%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/:0:0","tags":["tiptop gp","oracle","sql","bdl","运维","T100","erp"],"title":"效能常规处理流程","uri":"/%E6%95%88%E8%83%BD%E5%B8%B8%E8%A7%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/"},{"categories":["系统运维","编程问题"],"content":"大量作业都卡顿 当客户反馈所有作业都卡顿时，应当先检查服务器得基本状态，并保留截图，以便后面反馈给SE。 可检查得项目如下： 表空间状况和磁盘使用情况 已使用百分比，若将近100%，请截图提交SE处理。 的控件使用情况，如超过90%可以尝试增加后再查看系统卡顿情况。 表空间使用情况，使用超过90%和可用连续空间不足10M，都会导致作业使用卡顿，增加表空间后再查看卡顿情况。 检查系统负载情况 运行命令top后按c 命令关闭）后再查看效能。 数量如果超过5，表示系统负载很大。遇到这周情况请直接截图提交SE。 检查CPU，内存登占用情况 cpu（s）：cpu 总使用率（不大于40%为负载正常） 使用不多，代表内存空间足够 不建议测试IO性能，测试过程中可能导致正常运行进程闪退，如果怀疑可以交由SE处理 检查数据库响应时间 CREATE TABLE test_t (test001 VARCHAR(20)); DROP TABLE test_t; -处理。-检查AP和DB的网络连接速度-\u003ccode\u003eps-ef|grepora_smon\u003c/code\u003e运行命令`ping$FGLSERVER`检测网络延迟，若`time`时间超过0.3ms，需要注意网络延迟，如果数值特别高超过300ms，请直接联系客户，请客户先解决网络问题。需注意## 个别作业效能分析步骤 可按照下面步骤排查：1.判断是否需要清除ORACLE缓存直接执行作业，如果执行速度和客户反馈的不一样，例如：客户反馈审核要2分钟，还原后重新审核只要几秒钟。这个时候需要执行一下清除ORACLE缓存的语句，清除复杂SQL的缓存，之后再继续测试效能。```sqlALTERSYSTEMFLUSHSHARED_POOL;ALTERSYSTEMFLUSHBUFFER_CACHE;ALTERSYSTEMFLUSHGLOBALCONTEXT; 使用效能工具分析作业情况 工具运行作业分析即可 FGLSQLDEBUG 运行下面两个命令，开启日志开启后，运行命令会将每个连接数据库语句执行状况在后台显示出来。 FGLSQLDEBUG=9 export FGLSQLDEBUG 指定日志目录运行作业 exe2 aapt110 \u003e\u003e aapt110.lixwz.log 2\u003e\u00261 作业运行后关掉，运行一下命令开始分析日志 $FGLRUN $DS4GL/bin/fgldebug.42r aapt110.lixwz.log 💡 目录下若没有 fgldebug相关文件，需要先将效能工具相关文件上传到此目录，并运行chmod 777 fgldebug* 给与运行权限。 分析效能工具执行结果 RUN_TIME 为总运行时间，AVG_TIME为平均一次运行时间，主要关注这两列。 在进行sql分析之前，先对比标准主机，是否有追单。也关注下相关表索引是否和标准主机一致。 平均运行时间长，可根据PROG_NAME和RUN_LINE 抓取到运行的sql，进行SQL TRACE分析优化 平均运行时间正常，总运行时间长，即单个sql运行次数比较多。程序逻辑需要调整，例如：将FOREACH 操作改成临时表操作，借助数据库完成资料处理。 ","date":"2023年 11月16日","objectID":"/%E6%95%88%E8%83%BD%E5%B8%B8%E8%A7%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/:1:0","tags":["tiptop gp","oracle","sql","bdl","运维","T100","erp"],"title":"效能常规处理流程","uri":"/%E6%95%88%E8%83%BD%E5%B8%B8%E8%A7%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/"},{"categories":["系统运维","编程问题"],"content":"SQL TRACE 分析 使用plsql按F5进入SQL TRACE 索引查询 修改一下，可能就不走索引查询，查询时间也增加了很多。 ","date":"2023年 11月16日","objectID":"/%E6%95%88%E8%83%BD%E5%B8%B8%E8%A7%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/:2:0","tags":["tiptop gp","oracle","sql","bdl","运维","T100","erp"],"title":"效能常规处理流程","uri":"/%E6%95%88%E8%83%BD%E5%B8%B8%E8%A7%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/"},{"categories":["系统运维","编程问题"],"content":"导致索引失败 索引字段使用函数，如：substr(ima01,1,2)='10' 新建表索引信息还未建立完成，analyze table ima_file compute statistics; 运行分析一下 使用\u003c\u003e、not in 、not exist 表的资料比较少 单独的\u003e、\u003c like \"%_\" 百分号在前 单独引用复合索引里非第一位置的索引列，例如：索引为(ima01,ima02,ima03)条件为ima01 = ‘MISC’ ima02 =‘MISC’ ima03 = ‘MISC’ ima02 = 'MISC' 字符型字段为数字时在where条件里不添加引号,(自动走转换函数) 当变量采用的是times变量，而表的字段采用的是date变量时.或相反情况 索引失效，可以考虑重建索引，rebuild online 索引列空值 查询资料已超过总资料一定比例，默认是30% ","date":"2023年 11月16日","objectID":"/%E6%95%88%E8%83%BD%E5%B8%B8%E8%A7%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/:2:1","tags":["tiptop gp","oracle","sql","bdl","运维","T100","erp"],"title":"效能常规处理流程","uri":"/%E6%95%88%E8%83%BD%E5%B8%B8%E8%A7%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/"},{"categories":["系统运维","编程问题"],"content":"改写部分sql not in 、in 、not exist 、exist 可以用left join 或者 inner join 相互替代，那种效率高用哪种。 增加条件 条件前置，避免查出资料太多 UPDATE 优化 复杂条件的UPDATE语句，可以优化为MERGE方式。 --优化前 UPDATEq802_cfc_tmpoSETo.sum_qc=(SELECTNVL(SUM(cfc15*cfc18),0)FROMcfc_filec1WHERE(c1.cfc05\u003c2021OR(c1.cfc05=2021ANDc1.cfc06\u003c9))ANDc1.cfc21=0ANDc1.cfc22=0ANDc1.cfc01=1ANDc1.cfc07=o.cfc07ANDc1.cfc11=o.cfc11ANDc1.cfc17=o.cfc17) --优化后 MERGEINTOq802_cfc_tmpc1USING(SELECTcfc07,cfc11,cfc17,NVL(SUM(cfc15*cfc18),0)sum_qcFROMcfc_fileWHERE(cfc05\u003c2021OR(cfc05=2021ANDcfc06\u003c9))ANDcfc21=0ANDcfc22=0ANDcfc01=1GROUPBYcfc07,cfc11,cfc17)oON(c1.cfc07=o.cfc07ANDc1.cfc11=o.cfc11ANDc1.cfc17=o.cfc17)WHENMATCHEDTHENUPDATESETc1.sum_qc=o.sum_qc 临时表增加索引，执行中分析表 临时表处理的资料比较多时，可以适当增加索引 CREATE INDEX xcck_tmp_i02 ON xcck_tmp (xcckld,xcck003,xcck004,xcck005,xcck047) 如果是INSERT，UPDATE，DELETE语句比较卡顿还可以在执行前分析一下表，看效能是否改善 T100 直接运行函数 cl_db_generate_analyze(\"xcck_tmp\") TOPGP 可以使用下列命令 EXECUTE IMMEDIATE \"analyze table xccd_t estimate statistics\" ","date":"2023年 11月16日","objectID":"/%E6%95%88%E8%83%BD%E5%B8%B8%E8%A7%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/:2:2","tags":["tiptop gp","oracle","sql","bdl","运维","T100","erp"],"title":"效能常规处理流程","uri":"/%E6%95%88%E8%83%BD%E5%B8%B8%E8%A7%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/"},{"categories":["系统运维","编程问题"],"content":"案例分享 ","date":"2023年 11月16日","objectID":"/%E6%95%88%E8%83%BD%E5%B8%B8%E8%A7%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/:3:0","tags":["tiptop gp","oracle","sql","bdl","运维","T100","erp"],"title":"效能常规处理流程","uri":"/%E6%95%88%E8%83%BD%E5%B8%B8%E8%A7%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/"},{"categories":["系统运维","编程问题"],"content":"执行次数过多 平均执行时间0.06左右，不算高，但执行次数多达5W多次。 拉取其中sql分析 SELECTMAX(sfe04),MIN(sfe04)INTOg_tc_xea[g_cnt].hp_fddrq,g_tc_xea[g_cnt].hp_scfddrqFROMsfe_file,sfb_fileWHEREsfbud02=g_tc_xea[g_cnt].tc_xea01AND(sfb01LIKE'538%'ORsfb01LIKE'540%')ANDsfb01=sfe01 没有索引，将sfbud02增加索引，效果并不好（增加索引后效果不好记得删除） ，但无法进行下一步优化 是直接通过临时表取值，可以考虑直接将需要的字段再中间中处理 所以将所有SELECT语句改为更新临时表字段形式，然后FOREACH直接取值即可（临时表可能需要增加字段） 执行前先更新中间表 优化后，总执行时间已经减少了很多。 只需要执行一次，时间在0.1秒。 ","date":"2023年 11月16日","objectID":"/%E6%95%88%E8%83%BD%E5%B8%B8%E8%A7%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/:3:1","tags":["tiptop gp","oracle","sql","bdl","运维","T100","erp"],"title":"效能常规处理流程","uri":"/%E6%95%88%E8%83%BD%E5%B8%B8%E8%A7%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/"},{"categories":["系统运维","编程问题"],"content":"流程调整优化 用户反馈，此作业批量抛转时，速度很慢。 查询需要1分多钟 查询出结果后，勾选收款单号，每次都需要转圈很长时间才可以继续勾选 形式，速度有所改善，保留。 发现每次勾选收款单号之后，都会重新运行一遍单身显示得函数，所以导致批量抛转操作很慢。注释掉勾选后重新查询得逻辑，速度明显快很多，勾选不再需要等待。 💡 客制作业经常出现此类问题，测试时资料比较少，被忽略掉，这类问题优化时有限考虑mark掉不必要得流程。 ","date":"2023年 11月16日","objectID":"/%E6%95%88%E8%83%BD%E5%B8%B8%E8%A7%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/:3:2","tags":["tiptop gp","oracle","sql","bdl","运维","T100","erp"],"title":"效能常规处理流程","uri":"/%E6%95%88%E8%83%BD%E5%B8%B8%E8%A7%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/"},{"categories":["编程问题"],"content":"引入fglExt.h头文件 fglExt.h 在$FGLDIR/include/f2c目录下，我们需要用到暴露函数的结构体UsrFunction和出栈popvchar入栈pushvchar函数。 返回值和参数值不同类型请用不同的出栈入栈函数，popint、pushint等 以下示例，使用C语言新增函数base64Decode、base64Encode，用来base64格式的编码和解码。 ","date":"2023年 11月16日","objectID":"/%E6%96%B0%E5%A2%9Eblog/:1:0","tags":["c语言","linux","bdl"],"title":"新增BLOG","uri":"/%E6%96%B0%E5%A2%9Eblog/"},{"categories":["编程问题"],"content":"编写代码 ","date":"2023年 11月16日","objectID":"/%E6%96%B0%E5%A2%9Eblog/:2:0","tags":["c语言","linux","bdl"],"title":"新增BLOG","uri":"/%E6%96%B0%E5%A2%9Eblog/"},{"categories":["编程问题"],"content":"项目结构 为了方便后期维护，我将功能函数和函数暴露定义放在量个文件中，如下所示。 base64.c base64ext.c 功能函数就是实际处理逻辑，功能暴露函数定义了运行中传参、返回值个数、需要暴露的函数名称等参数。 为了后续可以增加多个函数，所以将暴露函数文件单独写。后面要引入其它功能函数，直接在这个文件中添加即可。实际你写在一个文件中也是没问题的。 c代码路径 源代码的路径可以在服务器任何位置，只要在服务器能够编译即可。 ","date":"2023年 11月16日","objectID":"/%E6%96%B0%E5%A2%9Eblog/:2:1","tags":["c语言","linux","bdl"],"title":"新增BLOG","uri":"/%E6%96%B0%E5%A2%9Eblog/"},{"categories":["编程问题"],"content":"逻辑函数 我的代码中主要函数是这两个，一个编码一个解码，若要希望BDL能直接调用，需要封装一下。 char* base64_decode(const char* str); char* base64_encode(const char* str); 函数的签名为int func(int);，此函数返回的是返回值数量，参数为BDL调用时的数量。 int base64Encode(int in_num){ const int sz = 5000; char src[sz]; char *ret; // assert需导入断言库\u003cassert.h\u003e，可以不用 assert(in_num==1); // 取参数 // popvchar取出当前栈最上面的参数，需导入头文件\"f2c/fglExt.h\"，才能使用 // 如果有多个参数，第一次取得值是最后一个参数，后入先出 popvchar(src,sz); if (*src == '\\\\0') { // pushvchar 返回值，如果有两个返回值，则调用两次pushvchar pushvchar(\"\", 0); return 1; } ret = base64_encode(src); pushvchar(ret, strlen(ret)); return 1; } ","date":"2023年 11月16日","objectID":"/%E6%96%B0%E5%A2%9Eblog/:2:2","tags":["c语言","linux","bdl"],"title":"新增BLOG","uri":"/%E6%96%B0%E5%A2%9Eblog/"},{"categories":["编程问题"],"content":"向外暴露函数 处理逻辑处理，还需要向外部暴露函数。base64ext.c 暴露函数得时候，使用一个结构体UsrFunction数组，其中： 是结束标志，必须以这个结束 每一行都是向BDL暴露一个函数 第一个参数为暴露得函数名，即BDL中要调用得名字 int func(int) 第三个参数为参数数量 第四个参数为返回值数量 ，表示数量可以变 #include \"f2c/fglExt.h\" // 申明函数签名 int base64Encode(int); int base64Decode(int); UsrFunction usrFunctions[]={ { \"base64Decode\", base64Decode, 1, 1 }, { \"base64Encode\", base64Encode, 1, 1 }, { 0,0,0,0 } }; ","date":"2023年 11月16日","objectID":"/%E6%96%B0%E5%A2%9Eblog/:2:3","tags":["c语言","linux","bdl"],"title":"新增BLOG","uri":"/%E6%96%B0%E5%A2%9Eblog/"},{"categories":["编程问题"],"content":"编译 编译c源文件 gcc -c -I $FGLDIR/include -fPIC base64.c gcc -c -I $FGLDIR/include -fPIC base64ext.c 此步将在当前目录产生对应的.o文件。 链接为so文件 gcc -shared -o libbase64.so base64.o base64ext.o -L$FGLDIR/lib -lfgl 此步产生so文件，so文件是我们运行时需要的文件，其它文件运行时都不需要。 so文件移动到$FGLLDPATH的目录中 $FGLLDPATH目录可以在$TOP/bin/tiptop_env文件中设置，所有的42m目录都在$FGLLDPATH中。 ","date":"2023年 11月16日","objectID":"/%E6%96%B0%E5%A2%9Eblog/:3:0","tags":["c语言","linux","bdl"],"title":"新增BLOG","uri":"/%E6%96%B0%E5%A2%9Eblog/"},{"categories":["编程问题"],"content":"调用 在BDL中只要importhi后即可使用这两个函数。 importlibbase64functionmain()definestr1,str2varchar(100)callbase64Encode(\"Hello World!\")returningstr1callbase64Decode(str1)returningstr2display\"\"display\"str1 is \"||str1display\"str2 is \"||str2endfunction ","date":"2023年 11月16日","objectID":"/%E6%96%B0%E5%A2%9Eblog/:4:0","tags":["c语言","linux","bdl"],"title":"新增BLOG","uri":"/%E6%96%B0%E5%A2%9Eblog/"},{"categories":["编程问题"],"content":"源码 base64.c #include \u003cstdio.h\u003e#include \u003cstring.h\u003e#include \u003cstdlib.h\u003e#include \u003cassert.h\u003e#include \"f2c/fglExt.h\" char* base64_decode(const char* str); char* base64_encode(const char* str); int base64Encode(int); int base64Decode(int); char* base64_decode(const char* str){ unsigned char imap[79]={62,0,0,0,63,52,53,54,55,56,57,58,59,60,61,0,0,0,0,0,0,0,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,0,0,0,0,0,0,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50}; int rest_count =0; int buf_idx=0; int len = strlen(str); int flen = len; int i; while(str[flen-1]=='=') flen--; int buflen = flen*6/8+1; unsigned char* buf = (unsigned char*) malloc(buflen); memset(buf,'\\\\0',buflen); for(i=0;i\u003cflen;i++){ unsigned char c=imap[str[i]-43]; int mcount = rest_count ==0?-2:6-rest_count; unsigned char c0 = (mcount\u003e0?c\u003e\u003emcount:c\u003c\u003c-mcount); buf[buf_idx] = buf[buf_idx] | c0; rest_count= mcount \u003c0 ? -mcount : 8-mcount; if(mcount\u003e=0) buf[++buf_idx]=c\u003c\u003crest_count; } return buf; } char* base64_encode(const char* str){ char map[65]=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"; int len =strlen(str); int buflen = len * 8 / 6 + 4;//缺位补齐1 俩等号2 最后0-1位 unsigned char* buf = (unsigned char*)malloc(buflen); memset(buf,'\\\\0',buflen); char a [4]; int i; int rest_count = 0; int index = 0; int buf_idx =0 ; unsigned char last = 0; for( i=0;i\u003clen;i++){ unsigned char c = str[i]; a[index]= (last\u003c\u003c(6-rest_count))\u002663; int get_count = 6-rest_count; a[index] = a[index] | ( c \u003e\u003e(8-get_count)); a[index]=map[a[index]]; rest_count = 8-get_count; last = c; index = index==2?0:index+1; if(index==0){ a[3]=map[c\u002663]; memcpy(buf+buf_idx,a,4); buf_idx+=4; rest_count=0; last = 0; } } if(index!=0){ a[index]= last\u003c\u003c(6-rest_count) \u0026 63; a[index]=map[a[index]]; memcpy(buf+buf_idx,a,index+1); buf[buf_idx+index+1]='='; buf[buf_idx+index+2]= rest_count ==2 ? '=':0; } return buf; } int base64Encode(int in_num){ const int sz = 5000; char src[sz]; char *ret; int *p; assert(in_num==1); // 取参数 popvchar(src,sz); if (*src == '\\\\0') { pushvchar(\"\", 0); return 1; } ret = base64_encode(src); pushvchar(ret, strlen(ret)); return 1; } int base64Decode(int in_num){ const int sz = 5000; char src[sz]; char *ret; int *p; assert(in_num == 1); // 取参数 popvchar(src,sz); if (*src == '\\\\0') { pushvchar(\"\", 0); return 1; } ret = base64_decode(src); pushvchar(ret, strlen(ret)); return 1; } base64ext.c #include \"f2c/fglExt.h\" int base64Encode(int); int base64Decode(int); UsrFunction usrFunctions[]={ { \"base64Decode\", base64Decode, 1, 1 }, { \"base64Encode\", base64Encode, 1, 1 }, { 0,0,0,0 } }; ","date":"2023年 11月16日","objectID":"/%E6%96%B0%E5%A2%9Eblog/:5:0","tags":["c语言","linux","bdl"],"title":"新增BLOG","uri":"/%E6%96%B0%E5%A2%9Eblog/"},{"categories":["ERP问题"],"content":"u1磁盘空间不足导致复制账套失败 情况适用于以下情况： 复制账套时，报错 EXP-00002: error in writing to export file 最后导出失败 ","date":"2023年 11月16日","objectID":"/%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E4%B8%8D%E8%B6%B3%E6%97%A0%E6%B3%95%E5%A4%8D%E5%88%B6%E8%B4%A6%E5%A5%97%E8%A7%A3%E5%86%B3/:1:0","tags":["linux","tiptop gp","运维"],"title":"磁盘空间不足无法复制账套解决","uri":"/%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E4%B8%8D%E8%B6%B3%E6%97%A0%E6%B3%95%E5%A4%8D%E5%88%B6%E8%B4%A6%E5%A5%97%E8%A7%A3%E5%86%B3/"},{"categories":["ERP问题"],"content":"如何判断是否是磁盘空间不足的2种方法 重新运行一遍aooi931建立sch。 若提示修改FGLPROFILE,直接vi $FGLPROFILE 删除掉复制的新账套信息。一般是最后几行，再次生成sch。 运行过程中观察磁盘空间，df -h，如果/u1磁盘空间一直增长到100%，即可判断是磁盘空间不足。 查看复制的来源账套的最近一次备份，解压之后的dmp文件如果大于u1剩余可用空间，就可判断磁盘空间不足 ","date":"2023年 11月16日","objectID":"/%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E4%B8%8D%E8%B6%B3%E6%97%A0%E6%B3%95%E5%A4%8D%E5%88%B6%E8%B4%A6%E5%A5%97%E8%A7%A3%E5%86%B3/:2:0","tags":["linux","tiptop gp","运维"],"title":"磁盘空间不足无法复制账套解决","uri":"/%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E4%B8%8D%E8%B6%B3%E6%97%A0%E6%B3%95%E5%A4%8D%E5%88%B6%E8%B4%A6%E5%A5%97%E8%A7%A3%E5%86%B3/"},{"categories":["ERP问题"],"content":"修改createsch脚本 createsch 默认目录 /u1/topprod/tiptop/ora/bin/createsch 将exp和imp语句中的文件位置修改为磁盘空间足够的目录 复制账套只用到第四条命令，可参考文件createsch 备注为lixwz exp $source/$ans5@$ORACLE_SID owner=${source} file=/u2/topprod/tiptop/tmp/${source}.dmp log=$TOP/tmp/exp_${source}.log imp system/$ans2@$ORACLE_SID fromuser=$source touser=$1 file=/u2/topprod/tiptop/tmp/${source}.dmp log=$TOP/tmp/imp_$1.log rm -f /u2/topprod/tiptop/tmp/${source}.dmp 上传完文件，注意文件的权限，用chmod修改 ","date":"2023年 11月16日","objectID":"/%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E4%B8%8D%E8%B6%B3%E6%97%A0%E6%B3%95%E5%A4%8D%E5%88%B6%E8%B4%A6%E5%A5%97%E8%A7%A3%E5%86%B3/:3:0","tags":["linux","tiptop gp","运维"],"title":"磁盘空间不足无法复制账套解决","uri":"/%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E4%B8%8D%E8%B6%B3%E6%97%A0%E6%B3%95%E5%A4%8D%E5%88%B6%E8%B4%A6%E5%A5%97%E8%A7%A3%E5%86%B3/"},{"categories":["软件安装","软件使用"],"content":"windows 安装 RUST 官网下载 rustup-init.exe，linux系统按照sh文件安装 (https://www.rust-lang.org/)[https://www.rust-lang.org/] 不安装多余文件，选择3然后安装RUSTUP。 安装默认cargo 检查是否安装成功 安装mdbook cargo install mdbook 以上为windows安装方式，发现安装时缺少很多文件，放弃，因为不想用mdbook需要安装一个vs。后面是linux 的教程，系统是ubuntu。 rustup self uninstall，卸载已安装的rustup linux 安装 安装rust 安装mdbook cargo install mdbook WSL2 使用本机proxy export ALL_PROXY=“http://192.168.1.1:7890” 192.168.1.1是本机的IP 在需要的目录初始化mdbook mdbook init ","date":"2023年 11月16日","objectID":"/mdbook%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B/:0:0","tags":["rust","mdbook"],"title":"mdbook安装过程","uri":"/mdbook%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B/"},{"categories":["软件安装","软件使用"],"content":"mdbook 使用 mdbook build 发布为html，默认为book目录 dbook build --dest-dir**** 指定目的文件夹 mkbook watch 实时转为html mkbook serve 打开网页服务，并实时显示 mkbook clean 清除已build的内容 ","date":"2023年 11月16日","objectID":"/mdbook%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B/:1:0","tags":["rust","mdbook"],"title":"mdbook安装过程","uri":"/mdbook%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B/"},{"categories":["软件安装","软件使用"],"content":"mermaid 插件安装 cargo install mdbook-mermaid 安装到要使用的目录 mdbook-mermaid install ./ 额外语言支持 theme/highlight.js 使用此文件替换mdbook默认文件 ","date":"2023年 11月16日","objectID":"/mdbook%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B/:1:1","tags":["rust","mdbook"],"title":"mdbook安装过程","uri":"/mdbook%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B/"},{"categories":["BDL教学"],"content":"模组清单 模组看起来很多，常用的只有下面几个： AAP 应付账款 ABM 产品结构系统 产品BOM结构 AEC 工艺与工作站系统 产品的工艺资料 AGL 总账会计 AIM 库存料件资料管理系统 AOO 整体系统管理 APM 采购管理 ANM 票据资金 AQC 质量管理 ASF 生产管理 AWS 集成管理 AXC 成本管理 AXM 销售管理 AXR 应收账款 AZZ 系统管理 SUB 一般副程序 LIB 公用程序 GAP 应付账款管理系统大陆版 模组编号A变为C，就变成了客制模组，客制添加的作业一般在客制模组。 如果模组第一个字母不是A，是直接加C，如CSUB、CLIB、CGAP。 ","date":"2023年 11月16日","objectID":"/erptiptop%E5%AF%B9%E8%B1%A1%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/:1:0","tags":["oracle","sql","bdl"],"title":"ERP（TIPTOP）对象命名规则","uri":"/erptiptop%E5%AF%B9%E8%B1%A1%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/"},{"categories":["BDL教学"],"content":"作业类型编码 不同类型的作业可以分为以下几类： 单档录入作业：i 单档参数作业：s 双档录入作业：t 查询作业：q 报表作业：r 批处理作业：p ","date":"2023年 11月16日","objectID":"/erptiptop%E5%AF%B9%E8%B1%A1%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/:2:0","tags":["oracle","sql","bdl"],"title":"ERP（TIPTOP）对象命名规则","uri":"/erptiptop%E5%AF%B9%E8%B1%A1%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/"},{"categories":["BDL教学"],"content":"程序命名规则 程序一般为4为字母和3为流水码组成。（部分模组为了让开发者更好记住，不是这样命名，如p_zz，p_zx，p_zxw这些都是azz模组下的作业，不按照此命名方式命名） 例如： aooi040 —\u003e aoo是模组的名称，i 是作业类型编号，040 是流水号。 这个作业是aoo整体系统管理模组下的一个单档可录入资料的作业。 ","date":"2023年 11月16日","objectID":"/erptiptop%E5%AF%B9%E8%B1%A1%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/:3:0","tags":["oracle","sql","bdl"],"title":"ERP（TIPTOP）对象命名规则","uri":"/erptiptop%E5%AF%B9%E8%B1%A1%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/"},{"categories":["BDL教学"],"content":"数据库命名规则 ","date":"2023年 11月16日","objectID":"/erptiptop%E5%AF%B9%E8%B1%A1%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/:4:0","tags":["oracle","sql","bdl"],"title":"ERP（TIPTOP）对象命名规则","uri":"/erptiptop%E5%AF%B9%E8%B1%A1%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/"},{"categories":["BDL教学"],"content":"数据库表名规则 数据库表名分为表名和固定后缀两个部分，ERP中所有正式表（在p_zta中注册的表）都有固定的后缀（_file）。 标准表 标准表的表名是三位字母，这是鼎捷出场就建立好的表。我们不会去动这些表名。 如工单单头表名：sfb_file 客制表 后续客制添加的表名是以tc_ 固定前缀，和三位字母加上固定的后缀_file 组成的。 例如你要客制一个表，可以用tc_sfb_file，这样的方式命名。其中tc_与_file都是固定的只有三位字母需要自己取名。 ","date":"2023年 11月16日","objectID":"/erptiptop%E5%AF%B9%E8%B1%A1%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/:4:1","tags":["oracle","sql","bdl"],"title":"ERP（TIPTOP）对象命名规则","uri":"/erptiptop%E5%AF%B9%E8%B1%A1%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/"},{"categories":["BDL教学"],"content":"数据库表字段规则 数据库的表字段也是由两部分组成 表名+流水码。 标准表的标准字段 流水码一般为2为流水码，有时候字段多，可以用多维流水码或者字母，这个限制不是太死。一般是2位流水码。 例如：工单单号字段 sfb01，看名称sfb就是表名，这个字段是sfb_file表的一个字段，01是流水码。 标准表的客制字段 如果标准表中的字段不够用，可以增加字段，增加的字段叫做客制字段。 客制字段需要在字段前加固定前缀****ta_，例如：sfb_file表中增加客制字段用来记录备注，可以命名为ta_sfb01 客制表的字段 客制表的字段也是表名+流水码，例如tc_sfb01，tc_sfb02 字段 undefine 在标准表中有一些定义了但是没有使用的字段，例如：sfbud01，sfbud02，这些字段定义了但是没有存储数据，我们后面可以使用这些字段。 当ud字段数量不够时，可以在增加ta_sfb01，ta_sfb02这些客制字段。 ","date":"2023年 11月16日","objectID":"/erptiptop%E5%AF%B9%E8%B1%A1%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/:4:2","tags":["oracle","sql","bdl"],"title":"ERP（TIPTOP）对象命名规则","uri":"/erptiptop%E5%AF%B9%E8%B1%A1%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/"},{"categories":["编程问题"],"content":" 断言—接口断言为确定类型 var greeting interface{} = \"hello world\" greetingStr := greeting.(string) 类型转换—底层结构一致的类型相互转换 greeting := []byte(\"hello world\") greetingStr := string(greeting) ","date":"2023年 11月16日","objectID":"/go-inteface/:0:0","tags":["golang"],"title":"go 类型转换与断言","uri":"/go-inteface/"},{"categories":["软件安装","软件使用"],"content":" git stash 是储藏的意思 本地代码落后远程一此commit，但是本地又修改了代码，不希望本地增加一次提交，可以使用git stash。 git stash 是将本地修改的内容暂时保存，当远程同步后，再将暂时保存的内容取出修改。 git stash pop 取出最近一次暂存代码 再次查看已经没有差异 ","date":"2023年 11月16日","objectID":"/git-stash/:0:0","tags":["git"],"title":"git stash 使用","uri":"/git-stash/"},{"categories":["系统运维"],"content":"最近运行平均时间较长SQL查询 select*from(selectsa.SQL_TEXT,sa.SQL_FULLTEXT,sa.EXECUTIONS\"执行次数\",round(sa.ELAPSED_TIME/1000000,2)\"总执行时间\",round(sa.ELAPSED_TIME/1000000/sa.EXECUTIONS,2)\"平均执行时间\",sa.COMMAND_TYPE,sa.PARSING_USER_ID\"用户ID\",u.username\"用户名\",sa.HASH_VALUEfromv$sqlareasaleftjoinall_usersuonsa.PARSING_USER_ID=u.user_idwheresa.EXECUTIONS\u003e0orderby(sa.ELAPSED_TIME/sa.EXECUTIONS)desc)whererownum\u003c=50; ","date":"2023年 11月16日","objectID":"/oracle-run-sql/:1:0","tags":["oracle","sql"],"title":"oracle最近运行SQL查询","uri":"/oracle-run-sql/"},{"categories":["系统运维"],"content":"最近运行SQL查询 SELECT*fromV$SQLWHEREsql_idISNOTNULL; ","date":"2023年 11月16日","objectID":"/oracle-run-sql/:2:0","tags":["oracle","sql"],"title":"oracle最近运行SQL查询","uri":"/oracle-run-sql/"},{"categories":["编程问题"],"content":" // 一次性写入 if err := os.WriteFile(\"file.txt\", []byte(\"Hello GOSAMPLES!\"), 0666); err != nil { log.Fatal(err) } // 逐行写入 package main import ( \"log\" \"os\" ) var lines = []string{ \"Go\", \"is\", \"the\", \"best\", \"programming\", \"language\", \"in\", \"the\", \"world\", } func main() { // create file f, err := os.Create(\"file.txt\") if err != nil { log.Fatal(err) } // remember to close the file defer f.Close() for _, line := range lines { _, err := f.WriteString(line + \"\\n\") if err != nil { log.Fatal(err) } } } // 写入byte package main import ( \"log\" \"os\" ) var bytes = []byte{ 0x47, // G 0x4f, // O 0x20, // \u003cspace\u003e 0x20, // \u003cspace\u003e 0x20, // \u003cspace\u003e 0x50, // P 0x4c, // L 0x45, // E 0x53, // S } var additionalBytes = []byte{ 0x53, // S 0x41, // A 0x4d, // M } func main() { // create file f, err := os.Create(\"file.txt\") if err != nil { log.Fatal(err) } // remember to close the file defer f.Close() // write bytes to the file _, err = f.Write(bytes) if err != nil { log.Fatal(err) } // write additional bytes to the file, start at index 2 _, err = f.WriteAt(additionalBytes, 2) if err != nil { log.Fatal(err) } } // 缓冲方式写入 package main import ( \"bufio\" \"log\" \"os\" ) var lines = []string{ \"Go\", \"is\", \"the\", \"best\", \"programming\", \"language\", \"in\", \"the\", \"world\", } func main() { // create file f, err := os.Create(\"file.txt\") if err != nil { log.Fatal(err) } // remember to close the file defer f.Close() // create new buffer buffer := bufio.NewWriter(f) for _, line := range lines { _, err := buffer.WriteString(line + \"\\n\") if err != nil { log.Fatal(err) } } // flush buffered data to the file if err := buffer.Flush(); err != nil { log.Fatal(err) } } ","date":"2023年 11月16日","objectID":"/golang-write/:0:0","tags":["golang","文件系统"],"title":"golang的文件写入","uri":"/golang-write/"},{"categories":["系统运维"],"content":"假设存在两个表： createtabledarcy1(ima01varchar(40),ima02varchar(40),ima021varchar(200));createtabledarcy2(ima01varchar(40),ima02varchar(40)) 运行下面代码不会出错，darcy2虽然没有ima021字段，但是SQL能匹配到darcy1有ima021字段，所以ima021字段被省略了。 select*fromdarcy1where(ima01,ima02,ima021)in(selectima01,ima02,ima021fromdarcy2whereima01like'M%') 以上代码结果等价于： select*fromdarcy1where(ima01,ima02)in(selectima01,ima02fromdarcy2whereima01like'M%') 所以嵌套的时候，如果两个表字段有可能重复，子查询中请尽量用表名.字段的形式。 ","date":"2023年 11月16日","objectID":"/sql-in-error/:0:0","tags":["oracle","sql","运维"],"title":"in嵌套错误字段问题","uri":"/sql-in-error/"},{"categories":["软件安装"],"content":" graph LR subgraph 6.服务端验证完毕: end subgraph 5.客户端发送验证后资料: j[\"客户端\"]--私钥解密--\u003ek[\"服务端\"] end subgraph 4.客户端请求服务段验证: e[\"服务端\"]--随机数据--\u003eg[\"客户端\"] end subgraph 3.客户端访问客户端: d[\"客户端\"]--\u003ef[\"服务端\"] end subgraph 2.私钥放到服务端: h[\"私钥\"]--放置--\u003ei[\"服务端\"] end subgraph 1.产生密钥: a[\"客户端\"]--生成--\u003eb[\"公钥\"] a--生成--\u003ec[\"私钥\"] end 产生ssh密钥 #产生ssh密钥 \u003e ssh-keygen Generating public/private rsa key pair. Enter file in which to save the key (C:\\Users\\darcy/.ssh/id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in C:\\Users\\darcy/.ssh/id_rsa Your public key has been saved in C:\\Users\\darcy/.ssh/id_rsa.pub The key fingerprint is: SHA256:NezN7f4OQQ183iHvX17y6QLijOTIDoWzhozgvo/tras darcy@darcy The key's randomart image is: +---[RSA 3072]----+ | .. | | . ..+.| | + +o+| | . o + o .o| |. o . S . o + | |= . + . . . ..oo| |.+ +. + + . . o+=| |. + oo o o o o+| | E=*+o ++o| +----[SHA256]-----+ ","date":"2023年 11月16日","objectID":"/ssh%E5%AF%86%E9%92%A5%E4%BD%BF%E7%94%A8/:0:0","tags":["ssh","远程开发"],"title":"ssh密钥使用","uri":"/ssh%E5%AF%86%E9%92%A5%E4%BD%BF%E7%94%A8/"},{"categories":["编程问题"],"content":"excel汇入 DEFINE xlapp INTEGER DEFINE xlwb INTEGER MAIN DEFINE result INTEGER DEFINE str STRING --initialization of global variables LET xlapp = -1 LET xlwb = -1 --first, we must create an Instance of an Excel Application CALL ui.Interface.frontCall(\"WinCOM\", \"CreateInstance\", [\"Excel.Application\"], [xlapp]) CALL CheckError(xlapp, __LINE__) --then adding a Workbook to the current document CALL ui.interface.frontCall(\"WinCOM\", \"CallMethod\", [xlapp, \"WorkBooks.Add\"], [xlwb]) CALL CheckError(xlwb, __LINE__) --then, setting it to be visible CALL ui.interface.frontCall(\"WinCOM\", \"SetProperty\", [xlapp, \"Visible\", true], [result]) CALL CheckError(result, __LINE__) --then CALL SetProperty to set the value of the cell CALL ui.Interface.frontCall(\"WinCOM\", \"SetProperty\", [xlwb, 'activesheet.Range(\"A1\").Value', \"foo\"],[result]) CALL CheckError(result, __LINE__) --then CALL GetProperty to check the value again CALL ui.Interface.frontCall(\"WinCOM\", \"GetProperty\", [xlwb, 'activesheet.Range(\"A1\").Value'], [str]) CALL CheckError(str, __LINE__) DISPLAY \"content of the cell is: \" || str --then Free the memory on the client side CALL freeMemory() END MAIN FUNCTION freeMemory() DEFINE res INTEGER IF xlwb != -1 THEN CALL ui.Interface.frontCall(\"WinCOM\",\"ReleaseInstance\", [xlwb], [res] ) END IF IF xlapp != -1 THEN CALL ui.Interface.frontCall(\"WinCOM\",\"ReleaseInstance\", [xlapp], [res] ) END IF END FUNCTION FUNCTION checkError(res, lin) DEFINE res INTEGER DEFINE lin INTEGER DEFINE mess STRING IF res = -1 THEN DISPLAY \"COM Error for call at line:\", lin CALL ui.Interface.frontCall(\"WinCOM\",\"GetError\",[],[mess]) DISPLAY mess --let's release the memory on the GDC side CALL freeMemory() DISPLAY \"Exit with COM Error.\" EXIT PROGRAM (-1) END IF END FUNCTION ","date":"2023年 11月16日","objectID":"/tiptop-gp-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E5%92%8C%E7%BC%96%E7%A8%8B%E6%96%B9%E5%BC%8F/:1:0","tags":["bdl","tiptop gp"],"title":"tiptop gp 常用的函数和编程方式","uri":"/tiptop-gp-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E5%92%8C%E7%BC%96%E7%A8%8B%E6%96%B9%E5%BC%8F/"},{"categories":["编程问题"],"content":"列表报错 CALL s_showmsg_init() LOOP CALL s_errmsg(field,date,msg,'mfg0301',1) END CALL s_showmsg() ","date":"2023年 11月16日","objectID":"/tiptop-gp-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E5%92%8C%E7%BC%96%E7%A8%8B%E6%96%B9%E5%BC%8F/:2:0","tags":["bdl","tiptop gp"],"title":"tiptop gp 常用的函数和编程方式","uri":"/tiptop-gp-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E5%92%8C%E7%BC%96%E7%A8%8B%E6%96%B9%E5%BC%8F/"},{"categories":["编程问题"],"content":"动态设置下拉框 DECLARE t310_curoqaud03 CURSOR FOR SELECT UNIQUE azi01 FROM azi_file LET g_oqaud03_cmbo = \"\" FOREACH t310_curoqaud03 INTO g_azi01 IF cl_null(g_oqaud03_cmbo) THEN LET g_oqaud03_cmbo=g_azi01 ELSE LET g_oqaud03_cmbo=g_oqaud03_cmbo CLIPPED,\",\",g_azi01 CLIPPED END IF END FOREACH CALL cl_set_combo_items(\"oqaud03\",g_oqaud03_cmbo,g_oqaud03_cmbo) ","date":"2023年 11月16日","objectID":"/tiptop-gp-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E5%92%8C%E7%BC%96%E7%A8%8B%E6%96%B9%E5%BC%8F/:3:0","tags":["bdl","tiptop gp"],"title":"tiptop gp 常用的函数和编程方式","uri":"/tiptop-gp-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E5%92%8C%E7%BC%96%E7%A8%8B%E6%96%B9%E5%BC%8F/"},{"categories":["编程问题"],"content":"字段显示颜色 ","date":"2023年 11月16日","objectID":"/tiptop-gp-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E5%92%8C%E7%BC%96%E7%A8%8B%E6%96%B9%E5%BC%8F/:4:0","tags":["bdl","tiptop gp"],"title":"tiptop gp 常用的函数和编程方式","uri":"/tiptop-gp-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E5%92%8C%E7%BC%96%E7%A8%8B%E6%96%B9%E5%BC%8F/"},{"categories":["编程问题"],"content":"表单 cl_chg_comp_att(ps_fields,ps_atts,ps_values) CALL cl_chg_comp_att(\"tc_ioa01,tc_ioa02\",\"color\",\"cyan\") 不支持的属性修改 LET lwin_curr = ui.Window.getCurrent() LET lfrm_curr = lwin_curr.getForm() LET lnode_item = lfrm_curr.findNode(\"FormField\",\"formonly.tc_ioa01\") LET lnode_child = lnode_item.getFirstChild() CALL lnode_child.setAttribute(\"underline\",true) 表格 利用DIALOG.setCellAttributes()函数 新增一个和单身数组字段一致的数组 DEFINE g_oeb_color DYNAMIC ARRAY OF RECORD c01 STRING,c02 STRING, c03 STRING,c04 STRING, c05 STRING,c06 STRING, c07 STRING,c08 STRING, c09 STRING,c10 STRING, c11 STRING,c12 STRING END RECORD 每笔单独设置颜色 LET g_oeb_color[2].c10 =\"red\" 在DISPLAY中设置显示模式 BEFORE DISPLAY ##显示之前设置属性 CALL DIALOG.setCellAttributes(g_oeb_color) ","date":"2023年 11月16日","objectID":"/tiptop-gp-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E5%92%8C%E7%BC%96%E7%A8%8B%E6%96%B9%E5%BC%8F/:4:1","tags":["bdl","tiptop gp"],"title":"tiptop gp 常用的函数和编程方式","uri":"/tiptop-gp-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E5%92%8C%E7%BC%96%E7%A8%8B%E6%96%B9%E5%BC%8F/"},{"categories":["ERP问题","系统运维"],"content":"环境变量FGLSQLDEBUG 此环境变量，控制运行程序时，后台显示日期的等级。 最高等级为9，取消设置命令为unset FGLSQLDEBUG 将环境变量设置为9 后，运行我们想要分析效能的程序，并将日志记录到文件中。 export FGLSQLDEBUG=9 exe2 p_zz \u003e\u003e p_zz.log 2\u003e\u00261 ","date":"2023年 11月16日","objectID":"/tiptop-%E6%95%88%E8%83%BD%E6%8E%92%E6%9F%A5/:1:0","tags":["bdl","debug","sql","oracle"],"title":"tiptop 效能排查","uri":"/tiptop-%E6%95%88%E8%83%BD%E6%8E%92%E6%9F%A5/"},{"categories":["ERP问题","系统运维"],"content":"分析日志 日志除了人工分析，系统也有作业可以分析。 $FGLRUN $DS4GL/bin/fgldebug.42r $FGLRUN $UTL/fbin/42m/T100SQLDebug.42r p_zz.log 即可打开效能分析工具 💡 r.r2d+和r.h分别时tiptop gp和T100的效能功能。如果环境没问题，直接运行 r.r2d+/r.h p_zz 也可以直接分析效能 ","date":"2023年 11月16日","objectID":"/tiptop-%E6%95%88%E8%83%BD%E6%8E%92%E6%9F%A5/:2:0","tags":["bdl","debug","sql","oracle"],"title":"tiptop 效能排查","uri":"/tiptop-%E6%95%88%E8%83%BD%E6%8E%92%E6%9F%A5/"},{"categories":["系统运维"],"content":"清楚查询缓存 ALTERSYSTEMFLUSHSHARED_POOL;ALTERSYSTEMFLUSHBUFFER_CACHE;ALTERSYSTEMFLUSHGLOBALCONTEXT; ","date":"2023年 11月16日","objectID":"/oracle-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B8%8Esql/:1:0","tags":["oracle","sql","运维"],"title":"oracle 常用命令与SQL","uri":"/oracle-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B8%8Esql/"},{"categories":["系统运维"],"content":"分析表结构 --① 分析表的所有字段，所有索引，所有索引字段。其中：① = ② analyzetablestudentcomputestatistics;--② 分析表的所有字段，所有索引，所有索引字段。其中：① = ② analyzetablestudentcomputestatisticsfortableforallindexesforallcolumns;--③ 只分析所有有索引的字段 analyzetablestudentcomputestatisticsfortableforallindexesforallindexedcolumns;--④ 抽样估算法 analyzetablestudentestimatestatisticssample20percent;--⑤ 删除分析数据 analyzetablestudentdeletestatistics;analyzetablestudentdeletestatisticsfortableforallindexesforallindexedcolumns;--查看表的统计信息 selecttable_name,num_rows,blocks,empty_blocksfromuser_tableswheretable_name='student';analyzetableglaq_tcomputestatistics; ","date":"2023年 11月16日","objectID":"/oracle-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B8%8Esql/:2:0","tags":["oracle","sql","运维"],"title":"oracle 常用命令与SQL","uri":"/oracle-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B8%8Esql/"},{"categories":["系统运维"],"content":"优化器 优先查询前25笔 SELECT/*+ FIRST_ROWS(25) */employee_id,department_idFROMhr.employeesWHEREdepartment_id\u003e50; 强制走索引 SELECT/*+index(a)*/*FROMsfb_fileLEFTJOINsfa_fileONsfa01=sfb01LEFTJOINima_fileaONa.ima01=sfb05LEFTJOINima_filebONb.ima01=sfa03LEFTJOINima_filecONc.ima01=sfa27 ","date":"2023年 11月16日","objectID":"/oracle-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B8%8Esql/:3:0","tags":["oracle","sql","运维"],"title":"oracle 常用命令与SQL","uri":"/oracle-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B8%8Esql/"},{"categories":["系统运维"],"content":"查询被删除的表 selectobject_name,original_name,partition_name,type,ts_name,createtime,droptimefromrecyclebin; 恢复删除的表 flashbacktabletest_droptobeforedrop;或flashbacktable\"BIN$hgcd$0\"tobeforedrop; ","date":"2023年 11月16日","objectID":"/oracle-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B8%8Esql/:4:0","tags":["oracle","sql","运维"],"title":"oracle 常用命令与SQL","uri":"/oracle-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B8%8Esql/"},{"categories":["系统运维"],"content":"清理临时表空间 setlinesize132;setpagesize0;settimingoff;spooldrop_tables.sql;SELECT'drop table '||OWNER||'.'||TABLE_name||' purge;'FROMdba_tablesWHEREtablespace_name='TEMPTABS';spooloff;@drop_tables.sql; ","date":"2023年 11月16日","objectID":"/oracle-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B8%8Esql/:5:0","tags":["oracle","sql","运维"],"title":"oracle 常用命令与SQL","uri":"/oracle-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B8%8Esql/"},{"categories":["系统运维"],"content":"查询某个时间之前的表状态（闪回） select*fromsfb_fileasoftimestampto_timestamp('2021-09-22 15:30:00','yyyy-mm-dd hh24:mi:ss') ","date":"2023年 11月16日","objectID":"/oracle-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B8%8Esql/:6:0","tags":["oracle","sql","运维"],"title":"oracle 常用命令与SQL","uri":"/oracle-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B8%8Esql/"},{"categories":["系统运维"],"content":"查询单个table占用磁盘空间 select*from(selectt.tablespace_name,t.owner,t.segment_name,t.segment_type,sum(t.bytes/1024/1024)mbfromdba_segmentstwheret.segment_type='TABLE'ANDtablespace_name='TEMPTABS'groupbyt.tablespace_name,t.OWNER,t.segment_name,t.segment_type)torderbyt.mbdesc; ","date":"2023年 11月16日","objectID":"/oracle-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B8%8Esql/:7:0","tags":["oracle","sql","运维"],"title":"oracle 常用命令与SQL","uri":"/oracle-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B8%8Esql/"},{"categories":["系统运维"],"content":"在备份中仅恢复部分表 准备号dmp备份文件 建立临时测试库 sqlplus system/manager@topprod create user test1 identified by test1 default tablespace dbs1; grant connect,resource to test1; commit; 恢复表 imp system/manager@topprod file=/u3/backup/Wed/exp_KT_20210203.dmp fromuser=kt touser=test1 tables=gen_file,eci_file ","date":"2023年 11月16日","objectID":"/oracle-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B8%8Esql/:8:0","tags":["oracle","sql","运维"],"title":"oracle 常用命令与SQL","uri":"/oracle-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B8%8Esql/"},{"categories":["系统运维"],"content":"增加表空间 命令查询表空间是否足够 查询表空间文件位置 增加合适大小表空间文件 alter tablespace xx add datafile 'xxx.dbf' size 4G; ","date":"2023年 11月16日","objectID":"/oracle-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B8%8Esql/:9:0","tags":["oracle","sql","运维"],"title":"oracle 常用命令与SQL","uri":"/oracle-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B8%8Esql/"},{"categories":["编程问题"],"content":"递归查询 -- 递归遍历查询 selectt.*,LEVELfromarea_testtstartwithname='郑州市'connectbypriorid=parent_id;selectbmb09frombmb_filewherebmb04\u003c=?and(bmb05isnullorbmb05\u003e?)startwithbmb01in(selectoeb04fromoeb_filewhereoeb01=?)connectbypriorbmb03=bmb01 ","date":"2023年 11月16日","objectID":"/oracle-sql%E8%AF%AD%E6%B3%95/:1:0","tags":["sql","oracle"],"title":"oracle sql语法","uri":"/oracle-sql%E8%AF%AD%E6%B3%95/"},{"categories":["编程问题"],"content":"pivot 列转行 WITHaAS(SELECT'darcy'na,'语文'ke,23scoreFROMdual),bAS(SELECT'tom','语文',23FROMdual),cAS(SELECT'darcy','数学',24FROMdual),dAS(SELECT*FROMaUNIONALLSELECT*FROMbUNIONALLSELECT*FROMc)SELECTna,语文,数学FROM(SELECTna,ke,scoreFROMd)PIVOT(SUM(score)FORkeIN('语文'AS语文,'数学'AS数学)); ","date":"2023年 11月16日","objectID":"/oracle-sql%E8%AF%AD%E6%B3%95/:2:0","tags":["sql","oracle"],"title":"oracle sql语法","uri":"/oracle-sql%E8%AF%AD%E6%B3%95/"},{"categories":["编程问题"],"content":"unpivot 行转列 WITHaAS(SELECT'darcy'na,'90'语文,'80'数学,'87'英语FROMdual)SELECTna,ke,scoreFROMaUNPIVOT(scoreforkein(语文,数学,英语)) ","date":"2023年 11月16日","objectID":"/oracle-sql%E8%AF%AD%E6%B3%95/:3:0","tags":["sql","oracle"],"title":"oracle sql语法","uri":"/oracle-sql%E8%AF%AD%E6%B3%95/"},{"categories":["编程问题"],"content":"keep 聚合的基础上再取最值 SELECTtc_bmj03,tc_bmj04,MAX(tc_bmj01)KEEP(dense_rankLASTorderBYtc_bmj09)max01FROMtc_bmj_fileWHEREtc_bmj11='2'GROUPBYtc_bmj03,tc_bmj04 ","date":"2023年 11月16日","objectID":"/oracle-sql%E8%AF%AD%E6%B3%95/:4:0","tags":["sql","oracle"],"title":"oracle sql语法","uri":"/oracle-sql%E8%AF%AD%E6%B3%95/"},{"categories":["编程问题"],"content":"over 分析 语法：rank()/dense_rank over(partition by A order by B) over是一种分析函数，根据字段A对结果进行分区，在各分区内按照字段进行排序； over不能单独使用，需要与row_number()，rank()和dense_rank，lag()和lead(),sum()等配合使用 说明： over()在什么条件之上 partition by 按哪个字段划分组 order by 按哪个字段排序 注意： 使用rank()/dense_rank() 时，必须要带order by否则非法 rank(): 跳跃排序，如果有两个第一级时，接下来就是第三级 dense_rank(): 连续排序，如果有两个第一级时，接下来仍然是第二级 SELECTfan01,fan03,fan04,fan15,dense_rank()OVER(PARTITIONBYfan01ORDERBYfan03DESC,fan04DESC)rFROMfan_fileWHEREfan041IN('0','1')ANDfan05IN('1','2')ANDfan01='FLYG200001' ","date":"2023年 11月16日","objectID":"/oracle-sql%E8%AF%AD%E6%B3%95/:5:0","tags":["sql","oracle"],"title":"oracle sql语法","uri":"/oracle-sql%E8%AF%AD%E6%B3%95/"},{"categories":["编程问题"],"content":"lag 偏移函数 可以查询上几条数据,下几条数据,适合查上下站资料 SELECTfan01,fan03,fan04,fan15,LAG(fan03||fan04)OVER(ORDERBYfan03DESC,fan04DESC)a1,LAG(fan03||fan04,2,0)OVER(ORDERBYfan03,fan04)a2FROMfan_fileWHEREfan041IN('0','1')ANDfan05IN('1','2')ANDfan01='FLYG200001'ORDERBYfan03,fan04 ","date":"2023年 11月16日","objectID":"/oracle-sql%E8%AF%AD%E6%B3%95/:6:0","tags":["sql","oracle"],"title":"oracle sql语法","uri":"/oracle-sql%E8%AF%AD%E6%B3%95/"},{"categories":["编程问题"],"content":"instr 字符串匹配函数 SELECTINSTR('123456789','2'),-- 返回：2 INSTR('123456654321','66'),-- 返回：6 INSTR('123456654321','66',6),-- 返回：6 INSTR('123456654321','66',8),-- 返回：0 INSTR('11223344','2',1,2),-- 返回：4 INSTR('11223344','2',2,3),-- 返回：0 INSTR('11223344','2',-1,2),-- 返回：3 INSTR('11223344','2',-6,1),-- 返回：3 INSTR('11223344','2',-6,2)-- 返回：0 FROMDUAL; ","date":"2023年 11月16日","objectID":"/oracle-sql%E8%AF%AD%E6%B3%95/:7:0","tags":["sql","oracle"],"title":"oracle sql语法","uri":"/oracle-sql%E8%AF%AD%E6%B3%95/"},{"categories":["编程问题"],"content":"listagg 聚合为一条数据 LISTAGG(字段名,',')WITHINGROUP(ORDERBY字段名) listagg(字段名,',')withinGROUP(orderby字段名)over(partitionby字段名)rank withtempas(select500population,'中国'nation,'江苏'cityfromdualunionallselect1500population,'中国'nation,'上海'cityfromdualunionallselect500population,'中国'nation,'北京'cityfromdualunionallselect1000population,'美国'nation,'纽约'cityfromdualunionallselect500population,'美国'nation,'波士顿'cityfromdualunionallselect500population,'日本'nation,'东京'cityfromdual)selectpopulation,nation,city,listagg(city,',')withinGROUP(orderbycity)over(partitionbynation)rankfromtemp ","date":"2023年 11月16日","objectID":"/oracle-sql%E8%AF%AD%E6%B3%95/:8:0","tags":["sql","oracle"],"title":"oracle sql语法","uri":"/oracle-sql%E8%AF%AD%E6%B3%95/"},{"categories":null,"content":"关于 LoveIt","date":"2019年 08月02日","objectID":"/about/","tags":null,"title":"关于 LoveIt","uri":"/about/"},{"categories":null,"content":"@darcyjoven 👋 🔭 I’m currently working at Forewin a company in suzhou.jiangsu.China 💬 Ask me about golang,fgl genero,ERP,javascript… 🖥 My blog site is: darcy’s blog 📘 My book site is: darcy’s book 📫 How to reach me: ✉ darcy_joven@live.com 📱 wechat:darcy_joven ","date":"2019年 08月02日","objectID":"/about/:0:0","tags":null,"title":"关于 LoveIt","uri":"/about/"}]