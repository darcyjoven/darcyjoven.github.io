[{"categories":["language"],"content":"pivot 函数,列转行 WITH a AS (SELECT 'darcy' na, '语文' ke, 23 score FROM dual), b AS (SELECT 'tom', '语文', 23 FROM dual), c AS (SELECT 'darcy', '数学', 24 FROM dual), d AS (SELECT * FROM a UNION ALL SELECT * FROM b UNION ALL SELECT * FROM c) SELECT na, 语文, 数学 FROM (SELECT na, ke, score FROM d) PIVOT (SUM(score) FOR ke IN('语文' AS 语文, '数学' AS 数学)); ","date":"2024年 05月28日","objectID":"/b8cae126/:1:0","tags":["SQL","ORACLE"],"title":"ORACLE常用函数-进阶","uri":"/b8cae126/"},{"categories":["language"],"content":"unpivot 函数,行转列 WITH a AS (SELECT 'darcy' na, '90' 语文, '80' 数学, '87' 英语 FROM dual) SELECT na, ke, score FROM a UNPIVOT(score for ke in(语文, 数学, 英语)) ","date":"2024年 05月28日","objectID":"/b8cae126/:2:0","tags":["SQL","ORACLE"],"title":"ORACLE常用函数-进阶","uri":"/b8cae126/"},{"categories":["language"],"content":"with as 临时数据 WITH a AS (SELECT 'darcy' na, '语文' ke, 23 score FROM dual), b AS (SELECT 'tom', '语文', 23 FROM dual), c AS (SELECT 'darcy', '数学', 24 FROM dual), d AS (SELECT * FROM a UNION ALL SELECT * FROM b UNION ALL SELECT * FROM c) SELECT * FROM d ","date":"2024年 05月28日","objectID":"/b8cae126/:3:0","tags":["SQL","ORACLE"],"title":"ORACLE常用函数-进阶","uri":"/b8cae126/"},{"categories":["language"],"content":"leading 指定链接表主表顺序 ","date":"2024年 05月28日","objectID":"/b8cae126/:4:0","tags":["SQL","ORACLE"],"title":"ORACLE常用函数-进阶","uri":"/b8cae126/"},{"categories":["language"],"content":"connect by 递归 SELECT LEVEL, CONNECT_BY_ISLEAF 是否无下阶料, bmb01, bmb03, SYS_CONNECT_BY_PATH(bmb01, '/') 路径, CONNECT_BY_ROOT(bmb01) root FROM bmb_file WHERE bmb04 \u003c= SYSDATE AND (bmb05 IS NULL OR bmb05 \u003e SYSDATE) START WITH bmb01 LIKE 'AA0011A3CR' --从这个资料开始 CONNECT BY PRIOR bmb03 = bmb01 --下笔资料的bmb03 和当前bmb01一样 ","date":"2024年 05月28日","objectID":"/b8cae126/:5:0","tags":["SQL","ORACLE"],"title":"ORACLE常用函数-进阶","uri":"/b8cae126/"},{"categories":["language"],"content":"keep函数,最值的基础上取最值 最新良率日期中的最大的单据编号 SELECT tc_bmj03,tc_bmj04,MAX(tc_bmj01) KEEP(dense_rank LAST order BY tc_bmj09) max01 FROM tc_bmj_file WHERE tc_bmj11 ='2' GROUP BY tc_bmj03,tc_bmj04 ","date":"2024年 05月28日","objectID":"/b8cae126/:6:0","tags":["SQL","ORACLE"],"title":"ORACLE常用函数-进阶","uri":"/b8cae126/"},{"categories":["language"],"content":"over 函数 语法：rank()/dense_rank over(partition by A order by B) over是一种分析函数，根据字段A对结果进行分区，在各分区内按照字段进行排序； over不能单独使用，需要与row_number()，rank()和dense_rank，lag()和lead(),sum()等配合使用 说明： over()在什么条件之上; partition by 按哪个字段划分组； order by 按哪个字段排序； 注意： 使用rank()/dense_rank() 时，必须要带order by否则非法； rank(): 跳跃排序，如果有两个第一级时，接下来就是第三级。 dense_rank(): 连续排序，如果有两个第一级时，接下来仍然是第二级。 SELECT fan01, fan03, fan04, fan15, dense_rank() OVER(PARTITION BY fan01 ORDER BY fan03 DESC, fan04 DESC) r FROM fan_file WHERE fan041 IN ('0', '1') AND fan05 IN ('1', '2') AND fan01 = 'FLYG200001' 根据年,月倒叙排序产生r列 ","date":"2024年 05月28日","objectID":"/b8cae126/:7:0","tags":["SQL","ORACLE"],"title":"ORACLE常用函数-进阶","uri":"/b8cae126/"},{"categories":["language"],"content":"lead()/lag() over(partition by … order by …) 偏移量函数 SELECT fan01, fan03, fan04, fan15, LAG(fan03||fan04) OVER (ORDER BY fan03 DESC ,fan04 DESC) a1, LAG(fan03||fan04,2,0) OVER (ORDER BY fan03,fan04) a2 FROM fan_file WHERE fan041 IN ('0', '1') AND fan05 IN ('1', '2') AND fan01 = 'FLYG200001' ORDER BY fan03,fan04 可以查询上几条数据,下几条数据,适合查上下站资料 ","date":"2024年 05月28日","objectID":"/b8cae126/:8:0","tags":["SQL","ORACLE"],"title":"ORACLE常用函数-进阶","uri":"/b8cae126/"},{"categories":["language"],"content":"instr 字符串匹配函数 SELECT INSTR('123456789','2'), -- 返回：2 INSTR('123456654321','66'), -- 返回：6 INSTR('123456654321','66',6), -- 返回：6 INSTR('123456654321','66',8), -- 返回：0 INSTR('11223344','2',1,2), -- 返回：4 INSTR('11223344','2',2,3), -- 返回：0 INSTR('11223344','2',-1,2), -- 返回：3 INSTR('11223344','2',-6,1), -- 返回：3 INSTR('11223344','2',-6,2) -- 返回：0 FROM DUAL ; ","date":"2024年 05月28日","objectID":"/b8cae126/:9:0","tags":["SQL","ORACLE"],"title":"ORACLE常用函数-进阶","uri":"/b8cae126/"},{"categories":["language"],"content":"nulls last/first null值排序 跟在order by 之后 Nulls first则表示null值的记录将排在最前 Nulls last则表示null值的记录将排在最后 ","date":"2024年 05月28日","objectID":"/b8cae126/:10:0","tags":["SQL","ORACLE"],"title":"ORACLE常用函数-进阶","uri":"/b8cae126/"},{"categories":["language"],"content":"集合操作 Union：对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序； Union All：对两个结果集进行并集操作，包括重复行，不进行排序； Intersect：对两个结果集进行交集操作，不包括重复行，同时进行默认规则的排序； Minus：对两个结果集进行差操作，不包括重复行，同时进行默认规则的排序。 ","date":"2024年 05月28日","objectID":"/b8cae126/:11:0","tags":["SQL","ORACLE"],"title":"ORACLE常用函数-进阶","uri":"/b8cae126/"},{"categories":["language"],"content":"listagg 聚合列为一条记录 LISTAGG(字段名,',') WITHIN GROUP( ORDER BY 字段名) listagg(字段名,',') within GROUP (order by 字段名) over (partition by 字段名) rank with temp as( select 500 population, '中国' nation ,'江苏' city from dual union all select 1500 population, '中国' nation ,'上海' city from dual union all select 500 population, '中国' nation ,'北京' city from dual union all select 1000 population, '美国' nation ,'纽约' city from dual union all select 500 population, '美国' nation ,'波士顿' city from dual union all select 500 population, '日本' nation ,'东京' city from dual ) select population, nation, city, listagg(city,',') within GROUP (order by city) over (partition by nation) rank from temp ","date":"2024年 05月28日","objectID":"/b8cae126/:12:0","tags":["SQL","ORACLE"],"title":"ORACLE常用函数-进阶","uri":"/b8cae126/"},{"categories":[""],"content":"升级前版本信息 ","date":"2024年 05月28日","objectID":"/8555b9e0/:0:0","tags":[""],"title":"RedHat6.5 GCC升级到4.8","uri":"/8555b9e0/"},{"categories":[""],"content":"red hat [root@ERP-AP02 ~]# cat /etc/redhat-release Red Hat Enterprise Linux Server release 6.5 (Santiago) ","date":"2024年 05月28日","objectID":"/8555b9e0/:1:0","tags":[""],"title":"RedHat6.5 GCC升级到4.8","uri":"/8555b9e0/"},{"categories":[""],"content":"GCC [root@ERP-AP02 ~]# gcc -v Using built-in specs. Target: x86_64-redhat-linux Configured with: ../configure --prefix=/usr --mandir=/usr/share/man --infodir=/usr/share/info --with-bugurl=http://bugzilla.redhat.com/bugzilla --enable-bootstrap --enable-shared --enable-threads=posix --enable-checking=release --with-system-zlib --enable-__cxa_atexit --disable-libunwind-exceptions --enable-gnu-unique-object --enable-languages=c,c++,objc,obj-c++,java,fortran,ada --enable-java-awt=gtk --disable-dssi --with-java-home=/usr/lib/jvm/java-1.5.0-gcj-1.5.0.0/jre --enable-libgcj-multifile --enable-java-maintainer-mode --with-ecj-jar=/usr/share/java/eclipse-ecj.jar --disable-libjava-multilib --with-ppl --with-cloog --with-tune=generic --with-arch_32=i686 --build=x86_64-redhat-linux Thread model: posix gcc version 4.4.7 20120313 (Red Hat 4.4.7-4) (GCC) 升级顺序 ","date":"2024年 05月28日","objectID":"/8555b9e0/:2:0","tags":[""],"title":"RedHat6.5 GCC升级到4.8","uri":"/8555b9e0/"},{"categories":[""],"content":"安装SCL https://prod-files-secure.s3.us-west-2.amazonaws.com/b1dbc1f7-4866-487d-86a2-41b94a254a88/fa71a4e6-eea0-402d-beb5-c49f2c53b5f3/centos-release-scl-rh-1-1.el6.centos.noarch.rpm?X-Amz-Algorithm=AWS4-HMAC-SHA256\u0026X-Amz-Content-Sha256=UNSIGNED-PAYLOAD\u0026X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240528%2Fus-west-2%2Fs3%2Faws4_request\u0026X-Amz-Date=20240528T081944Z\u0026X-Amz-Expires=3600\u0026X-Amz-Signature=d309fb2d933dd594f758066359b54bc42fb2cf62d93a03a3687613861c8803d9\u0026X-Amz-SignedHeaders=host\u0026x-id=GetObject rpm -ivh centos-release-scl-rh-1-1.el6.centos.noarch.rpm ","date":"2024年 05月28日","objectID":"/8555b9e0/:3:0","tags":[""],"title":"RedHat6.5 GCC升级到4.8","uri":"/8555b9e0/"},{"categories":[""],"content":"下载源码 wget http://ftp.gnu.org/gnu/gcc/gcc-4.8.0/gcc-4.8.0.tar.bz2 tar -jxvf gcc-4.8.0.tar.bz2 ","date":"2024年 05月28日","objectID":"/8555b9e0/:4:0","tags":[""],"title":"RedHat6.5 GCC升级到4.8","uri":"/8555b9e0/"},{"categories":[""],"content":"下载依赖库 cd gcc-4.8.0 ./contrib/download_prerequisites cd .. ","date":"2024年 05月28日","objectID":"/8555b9e0/:5:0","tags":[""],"title":"RedHat6.5 GCC升级到4.8","uri":"/8555b9e0/"},{"categories":[""],"content":"建立输出目录 mkdir gcc-build-4.8.0 ","date":"2024年 05月28日","objectID":"/8555b9e0/:6:0","tags":[""],"title":"RedHat6.5 GCC升级到4.8","uri":"/8555b9e0/"},{"categories":[""],"content":"产生makefile文件 cd gcc-build-4.8.0 ../gcc-4.8.0/configure –enable-checking=release –enable-languages=c,c++ –disable-multilib ","date":"2024年 05月28日","objectID":"/8555b9e0/:7:0","tags":[""],"title":"RedHat6.5 GCC升级到4.8","uri":"/8555b9e0/"},{"categories":[""],"content":"编译 make -j4 ","date":"2024年 05月28日","objectID":"/8555b9e0/:8:0","tags":[""],"title":"RedHat6.5 GCC升级到4.8","uri":"/8555b9e0/"},{"categories":[""],"content":"安装 make install ","date":"2024年 05月28日","objectID":"/8555b9e0/:9:0","tags":[""],"title":"RedHat6.5 GCC升级到4.8","uri":"/8555b9e0/"},{"categories":[""],"content":"切换新版本 updatedb locate gcc-4.8|tail ls /usr/local/bin | grep gcc update-alternatives –install /usr/bin/gcc gcc /usr/local/bin/i686-pc-linux-gnu-gcc 40 ","date":"2024年 05月28日","objectID":"/8555b9e0/:10:0","tags":[""],"title":"RedHat6.5 GCC升级到4.8","uri":"/8555b9e0/"},{"categories":["language"],"content":"DISPLAY 触发不了 DEFORE DISPLAY问题 利用page 标签 action 属性触发 主动触发row change IF g_sfdc_d[l_ac].sfdc005 != g_sfdc_d_o.sfdc005 END IF CALL DIALOG.setFieldTouched(\"s_detail2.*\", TRUE) END IF 修改部分字体大小 找到4st文件目录，此文件影响所有作业格式，修改前务必备份 修改4st文件，增加Menu的字体大小，还可以修改颜色，字体类型等 修改后如下 其它字段可以自己摸索，‘Menu’关键字是根据，DEBUG TREE找到，CTRL+右键 画面空白处可打开。 取当前时间 DEFINE d1, d2 DATETIME YEAR TO FRACTION(3) LET d1 = CURRENT YEAR TO FRACTION(3) LET d2 = \"1998-01-23 12:34\" DISPLAY d1, d2 YEAR MONTH DAY HOUR MINUTE SECOND FRACTION FRACTION(1) FRACTION(2) FRACTION(3) FRACTION(4) FRACTION(5) fglWrt 授权查询 fglWrt -a info sed 截取文件 sed -n '100,200p' 123.xml \u003e\u003e 12.xml 将123.xml 中从100行到200行内容复制到12.xml这个文件中。 💡 用处：大文件日志，不方便下载，其中的报文又不好复制的时候，可以用这个命令将需要的内容切割出来. grep 命令 直接用就是查询所有匹配内容 参数 -l grep -l \"hello,world!\" file_name 参数 -wo grep -wo \"keyword\" filename |wc -l 参数 -rn 这个参数可以查询匹配的文件名和所在行数 grep -rn \"hello,world!\" file_name 修改日期格式 export DBDATE=Y4MD/ 设置debug时，日期变为'yyyy/mm/dd'格式，不设置为'yy/mm/dd' ","date":"2024年 05月17日","objectID":"/eecc3b2c/:0:0","tags":["BDL","tiptop"],"title":"BDL部分开发问题","uri":"/eecc3b2c/"},{"categories":["ERP问题"],"content":"如何DEBUG TIPTOP ERP作业 ","date":"2023年 12月12日","objectID":"/debug-in-tiptop/:0:0","tags":["debug","erp","tiptop gp","T100"],"title":"如何DEBUG TIPTOP ERP作业","uri":"/debug-in-tiptop/"},{"categories":["ERP问题"],"content":"是否有权限DEBUG debug需要tiptop账号，如果你没有tiptop账号登陆权限，则无法debug erp作业。 有root权限也是可以切换到tiptop账号的。 su - tiptop 即可切换到tiptop账号，注意有两个空格。 ","date":"2023年 12月12日","objectID":"/debug-in-tiptop/:1:0","tags":["debug","erp","tiptop gp","T100"],"title":"如何DEBUG TIPTOP ERP作业","uri":"/debug-in-tiptop/"},{"categories":["ERP问题"],"content":"环境准备 登陆服务器 使用tiptop 登陆到ERP服务器，登陆到要测试的区。 打开画面测试 我们在服务器打开任意erp作业，exe p_zz r.r azzi910。如果能打开作业，环境没有问题，否则要检查下端口是否正常。 端口异常 GDC的默认端口为6400，如果你的端口不是6400，则需要在服务器上指定一下端口， export FGLSERVER=$FGLSERVER:6401 ","date":"2023年 12月12日","objectID":"/debug-in-tiptop/:2:0","tags":["debug","erp","tiptop gp","T100"],"title":"如何DEBUG TIPTOP ERP作业","uri":"/debug-in-tiptop/"},{"categories":["ERP问题"],"content":"运行前目录检查 debug时，我们也是通过调用42r文件运行作业的，所以不同目录我们可能运行不同作业。 T100 r.d azzi910 可以自动识别作业注册的目录，不用特意设置起始目录。（特殊情况可以切换到作业4gl目录下，使用r.dg azzi910，避免作业运行错误） TIPTOP GP 我们要确保切换到要运行的作业4gl目录，运行 r.d2+ p_zz 开始debug作业。（42m等其它目录也可以，一般默认到4gl目录） ","date":"2023年 12月12日","objectID":"/debug-in-tiptop/:3:0","tags":["debug","erp","tiptop gp","T100"],"title":"如何DEBUG TIPTOP ERP作业","uri":"/debug-in-tiptop/"},{"categories":["ERP问题"],"content":"DEBUG画面介绍 ","date":"2023年 12月12日","objectID":"/debug-in-tiptop/:4:0","tags":["debug","erp","tiptop gp","T100"],"title":"如何DEBUG TIPTOP ERP作业","uri":"/debug-in-tiptop/"},{"categories":["ERP问题"],"content":"查询代码 ctrl+F，可以弹出查询代码行数位置，可以跳转到指定代码位置，此方式只能查询当前代码位置 ","date":"2023年 12月12日","objectID":"/debug-in-tiptop/:4:1","tags":["debug","erp","tiptop gp","T100"],"title":"如何DEBUG TIPTOP ERP作业","uri":"/debug-in-tiptop/"},{"categories":["ERP问题"],"content":"重新运行 重新启动，即相当于重新打开作业 ","date":"2023年 12月12日","objectID":"/debug-in-tiptop/:4:2","tags":["debug","erp","tiptop gp","T100"],"title":"如何DEBUG TIPTOP ERP作业","uri":"/debug-in-tiptop/"},{"categories":["ERP问题"],"content":"运行 **F5 **运行到下一个断点处，如果没有断点，会一直运行到作业关闭 ","date":"2023年 12月12日","objectID":"/debug-in-tiptop/:4:3","tags":["debug","erp","tiptop gp","T100"],"title":"如何DEBUG TIPTOP ERP作业","uri":"/debug-in-tiptop/"},{"categories":["ERP问题"],"content":"进入函数 F11 进入函数，当前行如果有调用函数，使用此方式，可以进入函数内部 ","date":"2023年 12月12日","objectID":"/debug-in-tiptop/:4:4","tags":["debug","erp","tiptop gp","T100"],"title":"如何DEBUG TIPTOP ERP作业","uri":"/debug-in-tiptop/"},{"categories":["ERP问题"],"content":"跳出函数 **Shift+F11 **跳出函数，跳出当前运行的函数，如果时main函数，相当于运行到下一个断点 ","date":"2023年 12月12日","objectID":"/debug-in-tiptop/:4:5","tags":["debug","erp","tiptop gp","T100"],"title":"如何DEBUG TIPTOP ERP作业","uri":"/debug-in-tiptop/"},{"categories":["ERP问题"],"content":"单步运行 F10 可以单步运行，如果当前行有函数，会自动执行完函数，不会自动进入 ","date":"2023年 12月12日","objectID":"/debug-in-tiptop/:4:6","tags":["debug","erp","tiptop gp","T100"],"title":"如何DEBUG TIPTOP ERP作业","uri":"/debug-in-tiptop/"},{"categories":["ERP问题"],"content":"运行到下个断点 和F5功能差不多 ","date":"2023年 12月12日","objectID":"/debug-in-tiptop/:4:7","tags":["debug","erp","tiptop gp","T100"],"title":"如何DEBUG TIPTOP ERP作业","uri":"/debug-in-tiptop/"},{"categories":["ERP问题"],"content":"监测变量值 **Ctrl+I **，弹出变量监测窗口，你可以查看变量当前值，也可以将变量增加到监测窗口 ","date":"2023年 12月12日","objectID":"/debug-in-tiptop/:4:8","tags":["debug","erp","tiptop gp","T100"],"title":"如何DEBUG TIPTOP ERP作业","uri":"/debug-in-tiptop/"},{"categories":["ERP问题"],"content":"增加断点 在选中行增加或取消断点，快捷键F9，或者鼠标双击 ","date":"2023年 12月12日","objectID":"/debug-in-tiptop/:4:9","tags":["debug","erp","tiptop gp","T100"],"title":"如何DEBUG TIPTOP ERP作业","uri":"/debug-in-tiptop/"},{"categories":["ERP问题"],"content":"DEBUG 命令 bdl中支持一些命令，可以方便debug，这里说一些比较常用的类型，更多类型可以看帮助文档。 在画面中指定debug命令，要打开命令窗口运行，快捷键Ctrl+D，也可以在菜单Run→Execute Debugger Command ","date":"2023年 12月12日","objectID":"/debug-in-tiptop/:5:0","tags":["debug","erp","tiptop gp","T100"],"title":"如何DEBUG TIPTOP ERP作业","uri":"/debug-in-tiptop/"},{"categories":["ERP问题"],"content":"指定函数断点 b cl_cp_r 会在cl_cp_r函数第一行下一个断点 ","date":"2023年 12月12日","objectID":"/debug-in-tiptop/:6:0","tags":["debug","erp","tiptop gp","T100"],"title":"如何DEBUG TIPTOP ERP作业","uri":"/debug-in-tiptop/"},{"categories":["ERP问题"],"content":"改变变量的值 set variable g_user='tiptop’ 强行改变变量的值 ","date":"2023年 12月12日","objectID":"/debug-in-tiptop/:7:0","tags":["debug","erp","tiptop gp","T100"],"title":"如何DEBUG TIPTOP ERP作业","uri":"/debug-in-tiptop/"},{"categories":["ERP问题"],"content":"当变量值变化时自动暂停 watch g_user if g_user='tiptop’ ，当g_user变量变为’tiptop‘时，自动暂停 ","date":"2023年 12月12日","objectID":"/debug-in-tiptop/:8:0","tags":["debug","erp","tiptop gp","T100"],"title":"如何DEBUG TIPTOP ERP作业","uri":"/debug-in-tiptop/"},{"categories":["ERP问题"],"content":"接口的DEBUG ","date":"2023年 12月12日","objectID":"/debug-in-webservice/:0:0","tags":["erp","bdl","debug"],"title":"接口的DEBUG","uri":"/debug-in-webservice/"},{"categories":["ERP问题"],"content":"前提 普通作业的debug你已经会使用，后面会出一篇普通debug的使用。 ","date":"2023年 12月12日","objectID":"/debug-in-webservice/:1:0","tags":["erp","bdl","debug"],"title":"接口的DEBUG","uri":"/debug-in-webservice/"},{"categories":["ERP问题"],"content":"事先准备 下载可以抛砖测试的api测试软件，如soapui、postman这些软件，只要能抛转都可以用。 tiptop gp 的webservice 建议使用soapui比较方便，T100的Restful使用postman比较方便。 ","date":"2023年 12月12日","objectID":"/debug-in-webservice/:2:0","tags":["erp","bdl","debug"],"title":"接口的DEBUG","uri":"/debug-in-webservice/"},{"categories":["ERP问题"],"content":"软件配置 点击OK后，系统会自动产生对应的接口信息，如果未产生，请检查接口服务是否启动 ","date":"2023年 12月12日","objectID":"/debug-in-webservice/:3:0","tags":["erp","bdl","debug"],"title":"接口的DEBUG","uri":"/debug-in-webservice/"},{"categories":["ERP问题"],"content":"soap ui使用 点击你要测试的接口 ERP函数名称和接口名称对应关系可以在aws_ttcfg2中查到 这里要注意的是，\u003c要替换为\u0026lt; \u003c![CDATA[…]]\u003e 中的\u003c 不需要替换，因为已经转义过一次 点击运行，就能模拟一次正常的接口请求。 ","date":"2023年 12月12日","objectID":"/debug-in-webservice/:4:0","tags":["erp","bdl","debug"],"title":"接口的DEBUG","uri":"/debug-in-webservice/"},{"categories":["ERP问题"],"content":"DEBUG ERP程序 ","date":"2023年 12月12日","objectID":"/debug-in-webservice/:5:0","tags":["erp","bdl","debug"],"title":"接口的DEBUG","uri":"/debug-in-webservice/"},{"categories":["ERP问题"],"content":"指定断点 ERP的webservice程序为aws_ttsrv2，做过客制的话有可能是其它作业。 和正常作业一样，我们使用r.d2+ aws_ttsrv2进入到debug页面 我们在debug命令窗口，指定我们想要停止的断点，一般用我们需要停止的函数做断点即可。 ","date":"2023年 12月12日","objectID":"/debug-in-webservice/:5:1","tags":["erp","bdl","debug"],"title":"接口的DEBUG","uri":"/debug-in-webservice/"},{"categories":["ERP问题"],"content":"指定端口 断点指定好之后，我们需要指定一个端口用来测试，端口编号只要没有被占用即可 点击OK之后，我们就进入到了等待服务需求状态，这个时候debug会一直转圈等待。 ","date":"2023年 12月12日","objectID":"/debug-in-webservice/:5:2","tags":["erp","bdl","debug"],"title":"接口的DEBUG","uri":"/debug-in-webservice/"},{"categories":["ERP问题"],"content":"soap ui指定端口 我们将soap ui中的地址改为和debug一致的端口，然后点击提交。 这个时候debug会进入到断点处，我们开始和正常程序一样debug即可。如果需要重新抛转，在debug中点击允许，soap ui重新抛转一次，就可以在回到断点处。 ","date":"2023年 12月12日","objectID":"/debug-in-webservice/:6:0","tags":["erp","bdl","debug"],"title":"接口的DEBUG","uri":"/debug-in-webservice/"},{"categories":["ERP问题"],"content":" VPN和内部的网络访问只能是路由或是交换的方式，不能做NAT 客户端telnet到服务器后，在服务器端通过 echo $FGLSERVER 指令可以看到客户端VPN的IP 从服务器发起 ping / trace 到客户端VPN的IP可以正常访问 从服务器发起 telnet 客户端VPN的IP的 6400 端口可以正常访问 目前对客户端电脑的环境要求是Windows xp，Windows 7、8 ，IE版本8及以上，并且以管理员身份进入操作系统，其中IE11要设置兼容性设置，另外对于报表打印或者文档汇出，需要做如下设定： 设置IE为默认浏览器 把ERP网址和CR网址都加入到受信任站点，将受信任安全级别调到最低 如果无法弹出网页，请尝试关闭防火墙以及其他杀毒软件 ","date":"2023年 11月16日","objectID":"/erp%D1%87%D1%88%D1%94/:0:0","tags":["erp","运维","tiptop gp","T100"],"title":"ERP网络需求","uri":"/erp%D1%87%D1%88%D1%94/"},{"categories":["编程问题"],"content":"引入fglExt.h头文件 fglExt.h 在$FGLDIR/include/f2c目录下，我们需要用到暴露函数的结构体UsrFunction和出栈popvchar入栈pushvchar函数。 返回值和参数值不同类型请用不同的出栈入栈函数，popint、pushint等 以下示例，使用C语言新增函数base64Decode、base64Encode，用来base64格式的编码和解码。 ","date":"2023年 11月16日","objectID":"/bdl%D1%9Ec%D1%8F%D0%BF%D0%BC%D1%82.so/:1:0","tags":["c语言","linux","bdl"],"title":"BDL调用C语言动态库.so","uri":"/bdl%D1%9Ec%D1%8F%D0%BF%D0%BC%D1%82.so/"},{"categories":["编程问题"],"content":"编写代码 ","date":"2023年 11月16日","objectID":"/bdl%D1%9Ec%D1%8F%D0%BF%D0%BC%D1%82.so/:2:0","tags":["c语言","linux","bdl"],"title":"BDL调用C语言动态库.so","uri":"/bdl%D1%9Ec%D1%8F%D0%BF%D0%BC%D1%82.so/"},{"categories":["编程问题"],"content":"项目结构 为了方便后期维护，我将功能函数和函数暴露定义放在量个文件中，如下所示。 base64.c base64ext.c 功能函数就是实际处理逻辑，功能暴露函数定义了运行中传参、返回值个数、需要暴露的函数名称等参数。 为了后续可以增加多个函数，所以将暴露函数文件单独写。后面要引入其它功能函数，直接在这个文件中添加即可。实际你写在一个文件中也是没问题的。 c代码路径 源代码的路径可以在服务器任何位置，只要在服务器能够编译即可。 ","date":"2023年 11月16日","objectID":"/bdl%D1%9Ec%D1%8F%D0%BF%D0%BC%D1%82.so/:2:1","tags":["c语言","linux","bdl"],"title":"BDL调用C语言动态库.so","uri":"/bdl%D1%9Ec%D1%8F%D0%BF%D0%BC%D1%82.so/"},{"categories":["编程问题"],"content":"逻辑函数 我的代码中主要函数是这两个，一个编码一个解码，若要希望BDL能直接调用，需要封装一下。 char* base64_decode(const char* str); char* base64_encode(const char* str); 函数的签名为int func(int);，此函数返回的是返回值数量，参数为BDL调用时的数量。 int base64Encode(int in_num){ const int sz = 5000; char src[sz]; char *ret; // assert需导入断言库\u003cassert.h\u003e，可以不用 assert(in_num==1); // 取参数 // popvchar取出当前栈最上面的参数，需导入头文件\"f2c/fglExt.h\"，才能使用 // 如果有多个参数，第一次取得值是最后一个参数，后入先出 popvchar(src,sz); if (*src == '\\\\0') { // pushvchar 返回值，如果有两个返回值，则调用两次pushvchar pushvchar(\"\", 0); return 1; } ret = base64_encode(src); pushvchar(ret, strlen(ret)); return 1; } ","date":"2023年 11月16日","objectID":"/bdl%D1%9Ec%D1%8F%D0%BF%D0%BC%D1%82.so/:2:2","tags":["c语言","linux","bdl"],"title":"BDL调用C语言动态库.so","uri":"/bdl%D1%9Ec%D1%8F%D0%BF%D0%BC%D1%82.so/"},{"categories":["编程问题"],"content":"向外暴露函数 处理逻辑处理，还需要向外部暴露函数。base64ext.c 暴露函数得时候，使用一个结构体UsrFunction数组，其中： 是结束标志，必须以这个结束 每一行都是向BDL暴露一个函数 第一个参数为暴露得函数名，即BDL中要调用得名字 int func(int) 第三个参数为参数数量 第四个参数为返回值数量 ，表示数量可以变 #include \"f2c/fglExt.h\" // 申明函数签名 int base64Encode(int); int base64Decode(int); UsrFunction usrFunctions[]={ { \"base64Decode\", base64Decode, 1, 1 }, { \"base64Encode\", base64Encode, 1, 1 }, { 0,0,0,0 } }; ","date":"2023年 11月16日","objectID":"/bdl%D1%9Ec%D1%8F%D0%BF%D0%BC%D1%82.so/:2:3","tags":["c语言","linux","bdl"],"title":"BDL调用C语言动态库.so","uri":"/bdl%D1%9Ec%D1%8F%D0%BF%D0%BC%D1%82.so/"},{"categories":["编程问题"],"content":"编译 编译c源文件 gcc -c -I $FGLDIR/include -fPIC base64.c gcc -c -I $FGLDIR/include -fPIC base64ext.c 此步将在当前目录产生对应的.o文件。 链接为so文件 gcc -shared -o libbase64.so base64.o base64ext.o -L$FGLDIR/lib -lfgl 此步产生so文件，so文件是我们运行时需要的文件，其它文件运行时都不需要。 so文件移动到$FGLLDPATH的目录中 $FGLLDPATH目录可以在$TOP/bin/tiptop_env文件中设置，所有的42m目录都在$FGLLDPATH中。 ","date":"2023年 11月16日","objectID":"/bdl%D1%9Ec%D1%8F%D0%BF%D0%BC%D1%82.so/:3:0","tags":["c语言","linux","bdl"],"title":"BDL调用C语言动态库.so","uri":"/bdl%D1%9Ec%D1%8F%D0%BF%D0%BC%D1%82.so/"},{"categories":["编程问题"],"content":"调用 在BDL中只要importhi后即可使用这两个函数。 import libbase64 function main() define str1, str2 varchar(100) call base64Encode(\"Hello World!\") returning str1 call base64Decode(str1) returning str2 display \"\" display \"str1 is \"||str1 display \"str2 is \"||str2 end function ","date":"2023年 11月16日","objectID":"/bdl%D1%9Ec%D1%8F%D0%BF%D0%BC%D1%82.so/:4:0","tags":["c语言","linux","bdl"],"title":"BDL调用C语言动态库.so","uri":"/bdl%D1%9Ec%D1%8F%D0%BF%D0%BC%D1%82.so/"},{"categories":["编程问题"],"content":"源码 base64.c #include \u003cstdio.h\u003e #include \u003cstring.h\u003e #include \u003cstdlib.h\u003e #include \u003cassert.h\u003e #include \"f2c/fglExt.h\" char* base64_decode(const char* str); char* base64_encode(const char* str); int base64Encode(int); int base64Decode(int); char* base64_decode(const char* str){ unsigned char imap[79]={62,0,0,0,63,52,53,54,55,56,57,58,59,60,61,0,0,0,0,0,0,0,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,0,0,0,0,0,0,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50}; int rest_count =0; int buf_idx=0; int len = strlen(str); int flen = len; int i; while(str[flen-1]=='=') flen--; int buflen = flen*6/8+1; unsigned char* buf = (unsigned char*) malloc(buflen); memset(buf,'\\\\0',buflen); for(i=0;i\u003cflen;i++){ unsigned char c=imap[str[i]-43]; int mcount = rest_count ==0?-2:6-rest_count; unsigned char c0 = (mcount\u003e0?c\u003e\u003emcount:c\u003c\u003c-mcount); buf[buf_idx] = buf[buf_idx] | c0; rest_count= mcount \u003c0 ? -mcount : 8-mcount; if(mcount\u003e=0) buf[++buf_idx]=c\u003c\u003crest_count; } return buf; } char* base64_encode(const char* str){ char map[65]=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"; int len =strlen(str); int buflen = len * 8 / 6 + 4;//缺位补齐1 俩等号2 最后0-1位 unsigned char* buf = (unsigned char*)malloc(buflen); memset(buf,'\\\\0',buflen); char a [4]; int i; int rest_count = 0; int index = 0; int buf_idx =0 ; unsigned char last = 0; for( i=0;i\u003clen;i++){ unsigned char c = str[i]; a[index]= (last\u003c\u003c(6-rest_count))\u002663; int get_count = 6-rest_count; a[index] = a[index] | ( c \u003e\u003e(8-get_count)); a[index]=map[a[index]]; rest_count = 8-get_count; last = c; index = index==2?0:index+1; if(index==0){ a[3]=map[c\u002663]; memcpy(buf+buf_idx,a,4); buf_idx+=4; rest_count=0; last = 0; } } if(index!=0){ a[index]= last\u003c\u003c(6-rest_count) \u0026 63; a[index]=map[a[index]]; memcpy(buf+buf_idx,a,index+1); buf[buf_idx+index+1]='='; buf[buf_idx+index+2]= rest_count ==2 ? '=':0; } return buf; } int base64Encode(int in_num){ const int sz = 5000; char src[sz]; char *ret; int *p; assert(in_num==1); // 取参数 popvchar(src,sz); if (*src == '\\\\0') { pushvchar(\"\", 0); return 1; } ret = base64_encode(src); pushvchar(ret, strlen(ret)); return 1; } int base64Decode(int in_num){ const int sz = 5000; char src[sz]; char *ret; int *p; assert(in_num == 1); // 取参数 popvchar(src,sz); if (*src == '\\\\0') { pushvchar(\"\", 0); return 1; } ret = base64_decode(src); pushvchar(ret, strlen(ret)); return 1; } base64ext.c #include \"f2c/fglExt.h\" int base64Encode(int); int base64Decode(int); UsrFunction usrFunctions[]={ { \"base64Decode\", base64Decode, 1, 1 }, { \"base64Encode\", base64Encode, 1, 1 }, { 0,0,0,0 } }; ","date":"2023年 11月16日","objectID":"/bdl%D1%9Ec%D1%8F%D0%BF%D0%BC%D1%82.so/:5:0","tags":["c语言","linux","bdl"],"title":"BDL调用C语言动态库.so","uri":"/bdl%D1%9Ec%D1%8F%D0%BF%D0%BC%D1%82.so/"},{"categories":["编程问题"],"content":"fgl BDL调用dll库 ","date":"2023年 11月16日","objectID":"/bdl%D1%9Edll%D1%82/:0:0","tags":["bdl","dll","so","c语言","linux","tiptop gp","T100"],"title":"BDL调用dll库","uri":"/bdl%D1%9Edll%D1%82/"},{"categories":["编程问题"],"content":"MAC 和LINUX 原则上都支持 .dyLib 和 .so 都支持，因为用户较少所以未测试。 ","date":"2023年 11月16日","objectID":"/bdl%D1%9Edll%D1%82/:1:0","tags":["bdl","dll","so","c语言","linux","tiptop gp","T100"],"title":"BDL调用dll库","uri":"/bdl%D1%9Edll%D1%82/"},{"categories":["编程问题"],"content":"利用vs开发 在新建项目中选择此项 ","date":"2023年 11月16日","objectID":"/bdl%D1%9Edll%D1%82/:2:0","tags":["bdl","dll","so","c语言","linux","tiptop gp","T100"],"title":"BDL调用dll库","uri":"/bdl%D1%9Edll%D1%82/"},{"categories":["编程问题"],"content":"新增头文件 文件名随意，以下代码申明了需要的数据结构，调用时，通过此struct进行传参和接受回传。 #pragma once struct frontEndInterface { short (*getParamCount) (); short (*getReturnCount) (); void (*popInteger) (long\u0026, short\u0026); void (*pushInteger) (const long, short); void (*popString) (char*, short\u0026, short\u0026); void (*pushString) (const char*, short, short); void (*getFrontEndEnv) (const char*, char*, short\u0026); void (*popWString) (wchar_t*, short\u0026, short\u0026); void (*pushWString) (const wchar_t*, short, short); }; #ifdef WIN32 #define EXPORT extern \"C\" __declspec(dllexport) #else #define EXPORT extern \"C\" #endif // 下面时你要实现的函数。 EXPORT void initialize(); EXPORT void finalize(); EXPORT int mysum(const frontEndInterface\u0026 fx); ","date":"2023年 11月16日","objectID":"/bdl%D1%9Edll%D1%82/:3:0","tags":["bdl","dll","so","c语言","linux","tiptop gp","T100"],"title":"BDL调用dll库","uri":"/bdl%D1%9Edll%D1%82/"},{"categories":["编程问题"],"content":"编写实现函数 需要导入刚才完成的头文件，我这里是#include \"erpdemo.h\"。 // dllmain.cpp : 定义 DLL 应用程序的入口点。 #include \"pch.h\" #include \"erpdemo.h\" #include \u003cstdio.h\u003e #include \u003cstring.h\u003e /* BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved ) { switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; } return TRUE; } 这部分为vs自动生成。 */ void initialize() { } void finalize() { } int mysum(const struct frontEndInterface\u0026 fci) { long param1, param2; short isNull1, isNull2; long sum; char msg[255]; if (fci.getParamCount() != 2 || fci.getReturnCount() != 2) { return -1; } fci.popInteger(param2, isNull2); fci.popInteger(param1, isNull1); sum = param1 + param2; if (!isNull1 \u0026\u0026 !isNull2) { sum = param1 + param2; sprintf_s(msg, \"%d + %d = %d\", param1, param2, sum); } else { sum = 0; sprintf_s(msg, \"Parameters are NULL\"); } fci.pushInteger(sum, 0); fci.pushString(msg, strlen(msg), 0); return 0; } ","date":"2023年 11月16日","objectID":"/bdl%D1%9Edll%D1%82/:4:0","tags":["bdl","dll","so","c语言","linux","tiptop gp","T100"],"title":"BDL调用dll库","uri":"/bdl%D1%9Edll%D1%82/"},{"categories":["编程问题"],"content":"debug时会生成dll文件，将文件拷贝到gdc所在目录 ","date":"2023年 11月16日","objectID":"/bdl%D1%9Edll%D1%82/:5:0","tags":["bdl","dll","so","c语言","linux","tiptop gp","T100"],"title":"BDL调用dll库","uri":"/bdl%D1%9Edll%D1%82/"},{"categories":["编程问题"],"content":"BDL 调用 -- erpdemo 为dll名 -- mysum 为调用的函数名 -- [100,250] 为参数列表 -- [res,msg] 为回传的结果 CALL ui.Interface.frontCall(\"erpdemo\", \"mysum\", [100,250], [res,msg]) ","date":"2023年 11月16日","objectID":"/bdl%D1%9Edll%D1%82/:6:0","tags":["bdl","dll","so","c语言","linux","tiptop gp","T100"],"title":"BDL调用dll库","uri":"/bdl%D1%9Edll%D1%82/"},{"categories":["编程问题"],"content":"golang 编译 package main import \"C\" import \"fmt\" //export hello func hello(){ fmt.Println(\"hello world\") } //export add func add(a,b int) int { return a+b } func main(){ } golang中要导出的函数前要增加备注//export hello，且必须写有main函数。 import \"C\"也是必须导入的。 使用命令 go build -buildmode=c-shared -o xxx.so yyy 进行编译产生.so和.h文件，其中xxx是.so的文件名，yyy是项目名称。 如果编译之后未产生.h 文件，说明没有导出任何函数，请检查go源码。 编译产生的.so文件运行时需要，需要加载到$FGLDIR/lib目录下，也可以ln -s创建软链接。 ","date":"2023年 11月16日","objectID":"/bdl%D1%9Egolangcgo/:1:0","tags":["golang","c语言","tiptop gp","T100","so"],"title":"BDL调用golang(cgo)","uri":"/bdl%D1%9Egolangcgo/"},{"categories":["编程问题"],"content":"C语言封装 BDL调用C语言可以见BDL调用C语言 源码如下： #include \u003cstdio.h\u003e #include \"f2c/fglExt.h\" #include \"libsum.h\" int sum(int); GoInt Sum(GoInt,GoInt); UsrFunction usrFunctions[]={ { \"sum\", sum, 2, 1 }, { 0,0,0,0 } }; int sum(int in_num){ int s,a=0,b=0; popint(\u0026a); popint(\u0026b); s = Sum(a,b); pushint(s); return 1; } 产生.o 文件 gcc -c -I $FGLDIR/include -fPIC demo.c 产生.so文件 gcc -shared -o libsuma.so demo.o -L $FGLDIR/lib -lfgl -lsum 将产生的.so文件放到$FGLLDPATH的路径中 ","date":"2023年 11月16日","objectID":"/bdl%D1%9Egolangcgo/:2:0","tags":["golang","c语言","tiptop gp","T100","so"],"title":"BDL调用golang(cgo)","uri":"/bdl%D1%9Egolangcgo/"},{"categories":["编程问题"],"content":"BDL调用 import libsuma function main() define s integer call sum(2,3) returning s display sfmt(\"\\\\n2+3=%1\",s) end function BDL调用时只要调用libsuma即可，libsum会在libsuma调用后自动加载。 直接调用的.so 在$FGLLDPATH目录，c调用的.so在$FGLDIR/lib目录。 ","date":"2023年 11月16日","objectID":"/bdl%D1%9Egolangcgo/:3:0","tags":["golang","c语言","tiptop gp","T100","so"],"title":"BDL调用golang(cgo)","uri":"/bdl%D1%9Egolangcgo/"},{"categories":["编程问题"],"content":"fgl bdl语言集成java包 ","date":"2023年 11月16日","objectID":"/fgl-bdl%D1%8F%D0%BFjava/:0:0","tags":["tiptop gp","T100","java","linux"],"title":"fgl bdl语言集成java包","uri":"/fgl-bdl%D1%8F%D0%BFjava/"},{"categories":["编程问题"],"content":"确保java包版本和服务器jre版本一致 java -version ","date":"2023年 11月16日","objectID":"/fgl-bdl%D1%8F%D0%BFjava/:1:0","tags":["tiptop gp","T100","java","linux"],"title":"fgl bdl语言集成java包","uri":"/fgl-bdl%D1%8F%D0%BFjava/"},{"categories":["编程问题"],"content":"用静态类的方法返回值 bdl不支持面向对象编程（新版本支持单功能单一），所以用java静态类返回对象或者值来代替new Person()这种构建函数。 ","date":"2023年 11月16日","objectID":"/fgl-bdl%D1%8F%D0%BFjava/:2:0","tags":["tiptop gp","T100","java","linux"],"title":"fgl bdl语言集成java包","uri":"/fgl-bdl%D1%8F%D0%BFjava/"},{"categories":["编程问题"],"content":"jar 包配置 任意位置都可以，推荐位置$TOP/ds4gl2/bin/javaad/jar ","date":"2023年 11月16日","objectID":"/fgl-bdl%D1%8F%D0%BFjava/:3:0","tags":["tiptop gp","T100","java","linux"],"title":"fgl bdl语言集成java包","uri":"/fgl-bdl%D1%8F%D0%BFjava/"},{"categories":["编程问题"],"content":"CLASSPATH 设置 在文件$TOP/bin/tiptop_env中设置 设置好CLASSPATH后重新登陆tiptop查看jar包是否在CLASSPATH中 ","date":"2023年 11月16日","objectID":"/fgl-bdl%D1%8F%D0%BFjava/:4:0","tags":["tiptop gp","T100","java","linux"],"title":"fgl bdl语言集成java包","uri":"/fgl-bdl%D1%8F%D0%BFjava/"},{"categories":["编程问题"],"content":"BDL调用JAVA代码 代码最顶部导入要使用的类 IMPORT JAVA com.alibaba.fastjson.JSON IMPORT JAVA com.alibaba.fastjson.JSONArray IMPORT JAVA com.alibaba.fastjson.JSONObject 实际调用 // 定义java类型 DEFINE json_str RECORD cust_num INTEGER, cust_name VARCHAR(30), order_ids JSONArray, arr_list JSONArray END RECORD DEFINE json_obj JSONObject LET js = '{\"cust_num\":123,\"cust_name\":\"caozq\",\"order_ids\":[234,567,789],\"arr_list\":[{\"aa\":\"aa\",\"bb\":\"cc\"},{\"aa\":\"aa1\",\"bb\":\"bb1\"}]}' // 访问静态函数 LET json_obj = com.alibaba.fastjson.JSON.parseObject(js) // 访问对象属性 LET json_str.cust_num = json_obj.getIntValue(\"cust_num\") LET json_str.cust_name = json_obj.getString(\"cust_name\") ","date":"2023年 11月16日","objectID":"/fgl-bdl%D1%8F%D0%BFjava/:5:0","tags":["tiptop gp","T100","java","linux"],"title":"fgl bdl语言集成java包","uri":"/fgl-bdl%D1%8F%D0%BFjava/"},{"categories":["系统运维","编程问题"],"content":"效能常规处理方法 ","date":"2023年 11月16日","objectID":"/%D0%B7%D0%B3%D1%86%D0%B6%D1%8D%D1%9E/:0:0","tags":["tiptop gp","oracle","sql","bdl","运维","T100","erp"],"title":"效能常规处理流程","uri":"/%D0%B7%D0%B3%D1%86%D0%B6%D1%8D%D1%9E/"},{"categories":["系统运维","编程问题"],"content":"大量作业都卡顿 当客户反馈所有作业都卡顿时，应当先检查服务器得基本状态，并保留截图，以便后面反馈给SE。 可检查得项目如下： 表空间状况和磁盘使用情况 已使用百分比，若将近100%，请截图提交SE处理。 的控件使用情况，如超过90%可以尝试增加后再查看系统卡顿情况。 表空间使用情况，使用超过90%和可用连续空间不足10M，都会导致作业使用卡顿，增加表空间后再查看卡顿情况。 检查系统负载情况 运行命令top后按c 命令关闭）后再查看效能。 数量如果超过5，表示系统负载很大。遇到这周情况请直接截图提交SE。 检查CPU，内存登占用情况 cpu（s）：cpu 总使用率（不大于40%为负载正常） 使用不多，代表内存空间足够 不建议测试IO性能，测试过程中可能导致正常运行进程闪退，如果怀疑可以交由SE处理 检查数据库响应时间 CREATE TABLE test_t (test001 VARCHAR(20)); DROP TABLE test_t; - 处理。 - 检查AP和DB的网络连接速度 - \u003ccode\u003eps -ef|grep ora_smon\u003c/code\u003e 运行命令 `ping $FGLSERVER` 检测网络延迟，若`time` 时间超过0.3ms，需要注意网络延迟，如果数值特别高超过300ms，请直接联系客户，请客户先解决网络问题。 需注意 ## 个别作业效能分析步骤 可按照下面步骤排查： 1. 判断是否需要清除ORACLE缓存 直接执行作业，如果执行速度和客户反馈的不一样，例如：客户反馈审核要2分钟，还原后重新审核只要几秒钟。 这个时候需要执行一下清除ORACLE缓存的语句，清除复杂SQL的缓存，之后再继续测试效能。 ```sql ALTER SYSTEM FLUSH SHARED_POOL; ALTER SYSTEM FLUSH BUFFER_CACHE; ALTER SYSTEM FLUSH GLOBAL CONTEXT; 使用效能工具分析作业情况 工具运行作业分析即可 FGLSQLDEBUG 运行下面两个命令，开启日志开启后，运行命令会将每个连接数据库语句执行状况在后台显示出来。 FGLSQLDEBUG=9 export FGLSQLDEBUG 指定日志目录运行作业 exe2 aapt110 \u003e\u003e aapt110.lixwz.log 2\u003e\u00261 作业运行后关掉，运行一下命令开始分析日志 $FGLRUN $DS4GL/bin/fgldebug.42r aapt110.lixwz.log 💡 目录下若没有 fgldebug相关文件，需要先将效能工具相关文件上传到此目录，并运行chmod 777 fgldebug* 给与运行权限。 分析效能工具执行结果 RUN_TIME 为总运行时间，AVG_TIME为平均一次运行时间，主要关注这两列。 在进行sql分析之前，先对比标准主机，是否有追单。也关注下相关表索引是否和标准主机一致。 平均运行时间长，可根据PROG_NAME和RUN_LINE 抓取到运行的sql，进行SQL TRACE分析优化 平均运行时间正常，总运行时间长，即单个sql运行次数比较多。程序逻辑需要调整，例如：将FOREACH 操作改成临时表操作，借助数据库完成资料处理。 ","date":"2023年 11月16日","objectID":"/%D0%B7%D0%B3%D1%86%D0%B6%D1%8D%D1%9E/:1:0","tags":["tiptop gp","oracle","sql","bdl","运维","T100","erp"],"title":"效能常规处理流程","uri":"/%D0%B7%D0%B3%D1%86%D0%B6%D1%8D%D1%9E/"},{"categories":["系统运维","编程问题"],"content":"SQL TRACE 分析 使用plsql按F5进入SQL TRACE 索引查询 修改一下，可能就不走索引查询，查询时间也增加了很多。 ","date":"2023年 11月16日","objectID":"/%D0%B7%D0%B3%D1%86%D0%B6%D1%8D%D1%9E/:2:0","tags":["tiptop gp","oracle","sql","bdl","运维","T100","erp"],"title":"效能常规处理流程","uri":"/%D0%B7%D0%B3%D1%86%D0%B6%D1%8D%D1%9E/"},{"categories":["系统运维","编程问题"],"content":"导致索引失败 索引字段使用函数，如：substr(ima01,1,2)='10' 新建表索引信息还未建立完成，analyze table ima_file compute statistics; 运行分析一下 使用\u003c\u003e、not in 、not exist 表的资料比较少 单独的\u003e、\u003c like \"%_\" 百分号在前 单独引用复合索引里非第一位置的索引列，例如：索引为(ima01,ima02,ima03)条件为ima01 = ‘MISC’ ima02 =‘MISC’ ima03 = ‘MISC’ ima02 = 'MISC' 字符型字段为数字时在where条件里不添加引号,(自动走转换函数) 当变量采用的是times变量，而表的字段采用的是date变量时.或相反情况 索引失效，可以考虑重建索引，rebuild online 索引列空值 查询资料已超过总资料一定比例，默认是30% ","date":"2023年 11月16日","objectID":"/%D0%B7%D0%B3%D1%86%D0%B6%D1%8D%D1%9E/:2:1","tags":["tiptop gp","oracle","sql","bdl","运维","T100","erp"],"title":"效能常规处理流程","uri":"/%D0%B7%D0%B3%D1%86%D0%B6%D1%8D%D1%9E/"},{"categories":["系统运维","编程问题"],"content":"改写部分sql not in 、in 、not exist 、exist 可以用left join 或者 inner join 相互替代，那种效率高用哪种。 增加条件 条件前置，避免查出资料太多 UPDATE 优化 复杂条件的UPDATE语句，可以优化为MERGE方式。 --优化前 UPDATE q802_cfc_tmp o SET o.sum_qc= ( SELECT NVL(SUM(cfc15*cfc18),0) FROM cfc_file c1 WHERE(c1.cfc05\u003c2021 OR (c1.cfc05=2021 AND c1.cfc06\u003c9)) AND c1.cfc21=0 AND c1.cfc22 =0 AND c1.cfc01=1 AND c1.cfc07 = o.cfc07 AND c1.cfc11 = o.cfc11 AND c1.cfc17 = o.cfc17 ) --优化后 MERGE INTO q802_cfc_tmp c1 USING ( SELECT cfc07,cfc11,cfc17,NVL(SUM(cfc15 * cfc18), 0) sum_qc FROM cfc_file WHERE( cfc05 \u003c 2021 OR ( cfc05 = 2021 AND cfc06 \u003c 9 ) ) AND cfc21 = 0 AND cfc22 = 0 AND cfc01 = 1 GROUP BY cfc07,cfc11,cfc17 ) o ON ( c1.cfc07 = o.cfc07 AND c1.cfc11 = o.cfc11 AND c1.cfc17 = o.cfc17 ) WHEN MATCHED THEN UPDATE SET c1.sum_qc = o.sum_qc 临时表增加索引，执行中分析表 临时表处理的资料比较多时，可以适当增加索引 CREATE INDEX xcck_tmp_i02 ON xcck_tmp (xcckld,xcck003,xcck004,xcck005,xcck047) 如果是INSERT，UPDATE，DELETE语句比较卡顿还可以在执行前分析一下表，看效能是否改善 T100 直接运行函数 cl_db_generate_analyze(\"xcck_tmp\") TOPGP 可以使用下列命令 EXECUTE IMMEDIATE \"analyze table xccd_t estimate statistics\" ","date":"2023年 11月16日","objectID":"/%D0%B7%D0%B3%D1%86%D0%B6%D1%8D%D1%9E/:2:2","tags":["tiptop gp","oracle","sql","bdl","运维","T100","erp"],"title":"效能常规处理流程","uri":"/%D0%B7%D0%B3%D1%86%D0%B6%D1%8D%D1%9E/"},{"categories":["系统运维","编程问题"],"content":"案例分享 ","date":"2023年 11月16日","objectID":"/%D0%B7%D0%B3%D1%86%D0%B6%D1%8D%D1%9E/:3:0","tags":["tiptop gp","oracle","sql","bdl","运维","T100","erp"],"title":"效能常规处理流程","uri":"/%D0%B7%D0%B3%D1%86%D0%B6%D1%8D%D1%9E/"},{"categories":["系统运维","编程问题"],"content":"执行次数过多 平均执行时间0.06左右，不算高，但执行次数多达5W多次。 拉取其中sql分析 SELECT MAX(sfe04),MIN(sfe04) INTO g_tc_xea[g_cnt].hp_fddrq,g_tc_xea[g_cnt].hp_scfddrq FROM sfe_file,sfb_file WHERE sfbud02 = g_tc_xea[g_cnt].tc_xea01 AND (sfb01 LIKE '538%' OR sfb01 LIKE '540%') AND sfb01 = sfe01 没有索引，将sfbud02增加索引，效果并不好（增加索引后效果不好记得删除） ，但无法进行下一步优化 是直接通过临时表取值，可以考虑直接将需要的字段再中间中处理 所以将所有SELECT语句改为更新临时表字段形式，然后FOREACH直接取值即可（临时表可能需要增加字段） 执行前先更新中间表 优化后，总执行时间已经减少了很多。 只需要执行一次，时间在0.1秒。 ","date":"2023年 11月16日","objectID":"/%D0%B7%D0%B3%D1%86%D0%B6%D1%8D%D1%9E/:3:1","tags":["tiptop gp","oracle","sql","bdl","运维","T100","erp"],"title":"效能常规处理流程","uri":"/%D0%B7%D0%B3%D1%86%D0%B6%D1%8D%D1%9E/"},{"categories":["系统运维","编程问题"],"content":"流程调整优化 用户反馈，此作业批量抛转时，速度很慢。 查询需要1分多钟 查询出结果后，勾选收款单号，每次都需要转圈很长时间才可以继续勾选 形式，速度有所改善，保留。 发现每次勾选收款单号之后，都会重新运行一遍单身显示得函数，所以导致批量抛转操作很慢。注释掉勾选后重新查询得逻辑，速度明显快很多，勾选不再需要等待。 💡 客制作业经常出现此类问题，测试时资料比较少，被忽略掉，这类问题优化时有限考虑mark掉不必要得流程。 ","date":"2023年 11月16日","objectID":"/%D0%B7%D0%B3%D1%86%D0%B6%D1%8D%D1%9E/:3:2","tags":["tiptop gp","oracle","sql","bdl","运维","T100","erp"],"title":"效能常规处理流程","uri":"/%D0%B7%D0%B3%D1%86%D0%B6%D1%8D%D1%9E/"},{"categories":["ERP问题"],"content":"u1磁盘空间不足导致复制账套失败 情况适用于以下情况： 复制账套时，报错 EXP-00002: error in writing to export file 最后导出失败 ","date":"2023年 11月16日","objectID":"/%D1%84%D1%83%D0%B8%D1%82%D1%9E/:1:0","tags":["linux","tiptop gp","运维"],"title":"磁盘空间不足无法复制账套解决","uri":"/%D1%84%D1%83%D0%B8%D1%82%D1%9E/"},{"categories":["ERP问题"],"content":"如何判断是否是磁盘空间不足的2种方法 重新运行一遍aooi931建立sch。 若提示修改FGLPROFILE,直接vi $FGLPROFILE 删除掉复制的新账套信息。一般是最后几行，再次生成sch。 运行过程中观察磁盘空间，df -h，如果/u1磁盘空间一直增长到100%，即可判断是磁盘空间不足。 查看复制的来源账套的最近一次备份，解压之后的dmp文件如果大于u1剩余可用空间，就可判断磁盘空间不足 ","date":"2023年 11月16日","objectID":"/%D1%84%D1%83%D0%B8%D1%82%D1%9E/:2:0","tags":["linux","tiptop gp","运维"],"title":"磁盘空间不足无法复制账套解决","uri":"/%D1%84%D1%83%D0%B8%D1%82%D1%9E/"},{"categories":["ERP问题"],"content":"修改createsch脚本 createsch 默认目录 /u1/topprod/tiptop/ora/bin/createsch 将exp和imp语句中的文件位置修改为磁盘空间足够的目录 复制账套只用到第四条命令，可参考文件createsch 备注为lixwz exp $source/$ans5@$ORACLE_SID owner=${source} file=/u2/topprod/tiptop/tmp/${source}.dmp log=$TOP/tmp/exp_${source}.log imp system/$ans2@$ORACLE_SID fromuser=$source touser=$1 file=/u2/topprod/tiptop/tmp/${source}.dmp log=$TOP/tmp/imp_$1.log rm -f /u2/topprod/tiptop/tmp/${source}.dmp 上传完文件，注意文件的权限，用chmod修改 ","date":"2023年 11月16日","objectID":"/%D1%84%D1%83%D0%B8%D1%82%D1%9E/:3:0","tags":["linux","tiptop gp","运维"],"title":"磁盘空间不足无法复制账套解决","uri":"/%D1%84%D1%83%D0%B8%D1%82%D1%9E/"},{"categories":["编程问题"],"content":"引入fglExt.h头文件 fglExt.h 在$FGLDIR/include/f2c目录下，我们需要用到暴露函数的结构体UsrFunction和出栈popvchar入栈pushvchar函数。 返回值和参数值不同类型请用不同的出栈入栈函数，popint、pushint等 以下示例，使用C语言新增函数base64Decode、base64Encode，用来base64格式的编码和解码。 ","date":"2023年 11月16日","objectID":"/%D1%9Eblog/:1:0","tags":["c语言","linux","bdl"],"title":"新增BLOG","uri":"/%D1%9Eblog/"},{"categories":["编程问题"],"content":"编写代码 ","date":"2023年 11月16日","objectID":"/%D1%9Eblog/:2:0","tags":["c语言","linux","bdl"],"title":"新增BLOG","uri":"/%D1%9Eblog/"},{"categories":["编程问题"],"content":"项目结构 为了方便后期维护，我将功能函数和函数暴露定义放在量个文件中，如下所示。 base64.c base64ext.c 功能函数就是实际处理逻辑，功能暴露函数定义了运行中传参、返回值个数、需要暴露的函数名称等参数。 为了后续可以增加多个函数，所以将暴露函数文件单独写。后面要引入其它功能函数，直接在这个文件中添加即可。实际你写在一个文件中也是没问题的。 c代码路径 源代码的路径可以在服务器任何位置，只要在服务器能够编译即可。 ","date":"2023年 11月16日","objectID":"/%D1%9Eblog/:2:1","tags":["c语言","linux","bdl"],"title":"新增BLOG","uri":"/%D1%9Eblog/"},{"categories":["编程问题"],"content":"逻辑函数 我的代码中主要函数是这两个，一个编码一个解码，若要希望BDL能直接调用，需要封装一下。 char* base64_decode(const char* str); char* base64_encode(const char* str); 函数的签名为int func(int);，此函数返回的是返回值数量，参数为BDL调用时的数量。 int base64Encode(int in_num){ const int sz = 5000; char src[sz]; char *ret; // assert需导入断言库\u003cassert.h\u003e，可以不用 assert(in_num==1); // 取参数 // popvchar取出当前栈最上面的参数，需导入头文件\"f2c/fglExt.h\"，才能使用 // 如果有多个参数，第一次取得值是最后一个参数，后入先出 popvchar(src,sz); if (*src == '\\\\0') { // pushvchar 返回值，如果有两个返回值，则调用两次pushvchar pushvchar(\"\", 0); return 1; } ret = base64_encode(src); pushvchar(ret, strlen(ret)); return 1; } ","date":"2023年 11月16日","objectID":"/%D1%9Eblog/:2:2","tags":["c语言","linux","bdl"],"title":"新增BLOG","uri":"/%D1%9Eblog/"},{"categories":["编程问题"],"content":"向外暴露函数 处理逻辑处理，还需要向外部暴露函数。base64ext.c 暴露函数得时候，使用一个结构体UsrFunction数组，其中： 是结束标志，必须以这个结束 每一行都是向BDL暴露一个函数 第一个参数为暴露得函数名，即BDL中要调用得名字 int func(int) 第三个参数为参数数量 第四个参数为返回值数量 ，表示数量可以变 #include \"f2c/fglExt.h\" // 申明函数签名 int base64Encode(int); int base64Decode(int); UsrFunction usrFunctions[]={ { \"base64Decode\", base64Decode, 1, 1 }, { \"base64Encode\", base64Encode, 1, 1 }, { 0,0,0,0 } }; ","date":"2023年 11月16日","objectID":"/%D1%9Eblog/:2:3","tags":["c语言","linux","bdl"],"title":"新增BLOG","uri":"/%D1%9Eblog/"},{"categories":["编程问题"],"content":"编译 编译c源文件 gcc -c -I $FGLDIR/include -fPIC base64.c gcc -c -I $FGLDIR/include -fPIC base64ext.c 此步将在当前目录产生对应的.o文件。 链接为so文件 gcc -shared -o libbase64.so base64.o base64ext.o -L$FGLDIR/lib -lfgl 此步产生so文件，so文件是我们运行时需要的文件，其它文件运行时都不需要。 so文件移动到$FGLLDPATH的目录中 $FGLLDPATH目录可以在$TOP/bin/tiptop_env文件中设置，所有的42m目录都在$FGLLDPATH中。 ","date":"2023年 11月16日","objectID":"/%D1%9Eblog/:3:0","tags":["c语言","linux","bdl"],"title":"新增BLOG","uri":"/%D1%9Eblog/"},{"categories":["编程问题"],"content":"调用 在BDL中只要importhi后即可使用这两个函数。 import libbase64 function main() define str1, str2 varchar(100) call base64Encode(\"Hello World!\") returning str1 call base64Decode(str1) returning str2 display \"\" display \"str1 is \"||str1 display \"str2 is \"||str2 end function ","date":"2023年 11月16日","objectID":"/%D1%9Eblog/:4:0","tags":["c语言","linux","bdl"],"title":"新增BLOG","uri":"/%D1%9Eblog/"},{"categories":["编程问题"],"content":"源码 base64.c #include \u003cstdio.h\u003e #include \u003cstring.h\u003e #include \u003cstdlib.h\u003e #include \u003cassert.h\u003e #include \"f2c/fglExt.h\" char* base64_decode(const char* str); char* base64_encode(const char* str); int base64Encode(int); int base64Decode(int); char* base64_decode(const char* str){ unsigned char imap[79]={62,0,0,0,63,52,53,54,55,56,57,58,59,60,61,0,0,0,0,0,0,0,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,0,0,0,0,0,0,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50}; int rest_count =0; int buf_idx=0; int len = strlen(str); int flen = len; int i; while(str[flen-1]=='=') flen--; int buflen = flen*6/8+1; unsigned char* buf = (unsigned char*) malloc(buflen); memset(buf,'\\\\0',buflen); for(i=0;i\u003cflen;i++){ unsigned char c=imap[str[i]-43]; int mcount = rest_count ==0?-2:6-rest_count; unsigned char c0 = (mcount\u003e0?c\u003e\u003emcount:c\u003c\u003c-mcount); buf[buf_idx] = buf[buf_idx] | c0; rest_count= mcount \u003c0 ? -mcount : 8-mcount; if(mcount\u003e=0) buf[++buf_idx]=c\u003c\u003crest_count; } return buf; } char* base64_encode(const char* str){ char map[65]=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"; int len =strlen(str); int buflen = len * 8 / 6 + 4;//缺位补齐1 俩等号2 最后0-1位 unsigned char* buf = (unsigned char*)malloc(buflen); memset(buf,'\\\\0',buflen); char a [4]; int i; int rest_count = 0; int index = 0; int buf_idx =0 ; unsigned char last = 0; for( i=0;i\u003clen;i++){ unsigned char c = str[i]; a[index]= (last\u003c\u003c(6-rest_count))\u002663; int get_count = 6-rest_count; a[index] = a[index] | ( c \u003e\u003e(8-get_count)); a[index]=map[a[index]]; rest_count = 8-get_count; last = c; index = index==2?0:index+1; if(index==0){ a[3]=map[c\u002663]; memcpy(buf+buf_idx,a,4); buf_idx+=4; rest_count=0; last = 0; } } if(index!=0){ a[index]= last\u003c\u003c(6-rest_count) \u0026 63; a[index]=map[a[index]]; memcpy(buf+buf_idx,a,index+1); buf[buf_idx+index+1]='='; buf[buf_idx+index+2]= rest_count ==2 ? '=':0; } return buf; } int base64Encode(int in_num){ const int sz = 5000; char src[sz]; char *ret; int *p; assert(in_num==1); // 取参数 popvchar(src,sz); if (*src == '\\\\0') { pushvchar(\"\", 0); return 1; } ret = base64_encode(src); pushvchar(ret, strlen(ret)); return 1; } int base64Decode(int in_num){ const int sz = 5000; char src[sz]; char *ret; int *p; assert(in_num == 1); // 取参数 popvchar(src,sz); if (*src == '\\\\0') { pushvchar(\"\", 0); return 1; } ret = base64_decode(src); pushvchar(ret, strlen(ret)); return 1; } base64ext.c #include \"f2c/fglExt.h\" int base64Encode(int); int base64Decode(int); UsrFunction usrFunctions[]={ { \"base64Decode\", base64Decode, 1, 1 }, { \"base64Encode\", base64Encode, 1, 1 }, { 0,0,0,0 } }; ","date":"2023年 11月16日","objectID":"/%D1%9Eblog/:5:0","tags":["c语言","linux","bdl"],"title":"新增BLOG","uri":"/%D1%9Eblog/"},{"categories":["软件安装","软件使用"],"content":"windows 安装 RUST 官网下载 rustup-init.exe，linux系统按照sh文件安装 (https://www.rust-lang.org/)[https://www.rust-lang.org/] 不安装多余文件，选择3然后安装RUSTUP。 安装默认cargo 检查是否安装成功 安装mdbook cargo install mdbook 以上为windows安装方式，发现安装时缺少很多文件，放弃，因为不想用mdbook需要安装一个vs。后面是linux 的教程，系统是ubuntu。 rustup self uninstall，卸载已安装的rustup linux 安装 安装rust 安装mdbook cargo install mdbook WSL2 使用本机proxy export ALL_PROXY=“http://192.168.1.1:7890” 192.168.1.1是本机的IP 在需要的目录初始化mdbook mdbook init ","date":"2023年 11月16日","objectID":"/mdbook/:0:0","tags":["rust","mdbook"],"title":"mdbook安装过程","uri":"/mdbook/"},{"categories":["软件安装","软件使用"],"content":"mdbook 使用 mdbook build 发布为html，默认为book目录 dbook build --dest-dir**** 指定目的文件夹 mkbook watch 实时转为html mkbook serve 打开网页服务，并实时显示 mkbook clean 清除已build的内容 ","date":"2023年 11月16日","objectID":"/mdbook/:1:0","tags":["rust","mdbook"],"title":"mdbook安装过程","uri":"/mdbook/"},{"categories":["软件安装","软件使用"],"content":"mermaid 插件安装 cargo install mdbook-mermaid 安装到要使用的目录 mdbook-mermaid install ./ 额外语言支持 theme/highlight.js 使用此文件替换mdbook默认文件 ","date":"2023年 11月16日","objectID":"/mdbook/:1:1","tags":["rust","mdbook"],"title":"mdbook安装过程","uri":"/mdbook/"},{"categories":["BDL教学"],"content":"模组清单 模组看起来很多，常用的只有下面几个： AAP 应付账款 ABM 产品结构系统 产品BOM结构 AEC 工艺与工作站系统 产品的工艺资料 AGL 总账会计 AIM 库存料件资料管理系统 AOO 整体系统管理 APM 采购管理 ANM 票据资金 AQC 质量管理 ASF 生产管理 AWS 集成管理 AXC 成本管理 AXM 销售管理 AXR 应收账款 AZZ 系统管理 SUB 一般副程序 LIB 公用程序 GAP 应付账款管理系统大陆版 模组编号A变为C，就变成了客制模组，客制添加的作业一般在客制模组。 如果模组第一个字母不是A，是直接加C，如CSUB、CLIB、CGAP。 ","date":"2023年 11月16日","objectID":"/erp%D0%B3%D0%B8tiptop%D0%B3%D0%B9%D1%94%D1%86%D1%94/:1:0","tags":["oracle","sql","bdl"],"title":"ERP（TIPTOP）对象命名规则","uri":"/erp%D0%B3%D0%B8tiptop%D0%B3%D0%B9%D1%94%D1%86%D1%94/"},{"categories":["BDL教学"],"content":"作业类型编码 不同类型的作业可以分为以下几类： 单档录入作业：i 单档参数作业：s 双档录入作业：t 查询作业：q 报表作业：r 批处理作业：p ","date":"2023年 11月16日","objectID":"/erp%D0%B3%D0%B8tiptop%D0%B3%D0%B9%D1%94%D1%86%D1%94/:2:0","tags":["oracle","sql","bdl"],"title":"ERP（TIPTOP）对象命名规则","uri":"/erp%D0%B3%D0%B8tiptop%D0%B3%D0%B9%D1%94%D1%86%D1%94/"},{"categories":["BDL教学"],"content":"程序命名规则 程序一般为4为字母和3为流水码组成。（部分模组为了让开发者更好记住，不是这样命名，如p_zz，p_zx，p_zxw这些都是azz模组下的作业，不按照此命名方式命名） 例如： aooi040 —\u003e aoo是模组的名称，i 是作业类型编号，040 是流水号。 这个作业是aoo整体系统管理模组下的一个单档可录入资料的作业。 ","date":"2023年 11月16日","objectID":"/erp%D0%B3%D0%B8tiptop%D0%B3%D0%B9%D1%94%D1%86%D1%94/:3:0","tags":["oracle","sql","bdl"],"title":"ERP（TIPTOP）对象命名规则","uri":"/erp%D0%B3%D0%B8tiptop%D0%B3%D0%B9%D1%94%D1%86%D1%94/"},{"categories":["BDL教学"],"content":"数据库命名规则 ","date":"2023年 11月16日","objectID":"/erp%D0%B3%D0%B8tiptop%D0%B3%D0%B9%D1%94%D1%86%D1%94/:4:0","tags":["oracle","sql","bdl"],"title":"ERP（TIPTOP）对象命名规则","uri":"/erp%D0%B3%D0%B8tiptop%D0%B3%D0%B9%D1%94%D1%86%D1%94/"},{"categories":["BDL教学"],"content":"数据库表名规则 数据库表名分为表名和固定后缀两个部分，ERP中所有正式表（在p_zta中注册的表）都有固定的后缀（_file）。 标准表 标准表的表名是三位字母，这是鼎捷出场就建立好的表。我们不会去动这些表名。 如工单单头表名：sfb_file 客制表 后续客制添加的表名是以tc_ 固定前缀，和三位字母加上固定的后缀_file 组成的。 例如你要客制一个表，可以用tc_sfb_file，这样的方式命名。其中tc_与_file都是固定的只有三位字母需要自己取名。 ","date":"2023年 11月16日","objectID":"/erp%D0%B3%D0%B8tiptop%D0%B3%D0%B9%D1%94%D1%86%D1%94/:4:1","tags":["oracle","sql","bdl"],"title":"ERP（TIPTOP）对象命名规则","uri":"/erp%D0%B3%D0%B8tiptop%D0%B3%D0%B9%D1%94%D1%86%D1%94/"},{"categories":["BDL教学"],"content":"数据库表字段规则 数据库的表字段也是由两部分组成 表名+流水码。 标准表的标准字段 流水码一般为2为流水码，有时候字段多，可以用多维流水码或者字母，这个限制不是太死。一般是2位流水码。 例如：工单单号字段 sfb01，看名称sfb就是表名，这个字段是sfb_file表的一个字段，01是流水码。 标准表的客制字段 如果标准表中的字段不够用，可以增加字段，增加的字段叫做客制字段。 客制字段需要在字段前加固定前缀****ta_，例如：sfb_file表中增加客制字段用来记录备注，可以命名为ta_sfb01 客制表的字段 客制表的字段也是表名+流水码，例如tc_sfb01，tc_sfb02 字段 undefine 在标准表中有一些定义了但是没有使用的字段，例如：sfbud01，sfbud02，这些字段定义了但是没有存储数据，我们后面可以使用这些字段。 当ud字段数量不够时，可以在增加ta_sfb01，ta_sfb02这些客制字段。 ","date":"2023年 11月16日","objectID":"/erp%D0%B3%D0%B8tiptop%D0%B3%D0%B9%D1%94%D1%86%D1%94/:4:2","tags":["oracle","sql","bdl"],"title":"ERP（TIPTOP）对象命名规则","uri":"/erp%D0%B3%D0%B8tiptop%D0%B3%D0%B9%D1%94%D1%86%D1%94/"},{"categories":["编程问题"],"content":" 断言—接口断言为确定类型 var greeting interface{} = \"hello world\" greetingStr := greeting.(string) 类型转换—底层结构一致的类型相互转换 greeting := []byte(\"hello world\") greetingStr := string(greeting) ","date":"2023年 11月16日","objectID":"/go-inteface/:0:0","tags":["golang"],"title":"go 类型转换与断言","uri":"/go-inteface/"},{"categories":["软件安装","软件使用"],"content":" git stash 是储藏的意思 本地代码落后远程一此commit，但是本地又修改了代码，不希望本地增加一次提交，可以使用git stash。 git stash 是将本地修改的内容暂时保存，当远程同步后，再将暂时保存的内容取出修改。 git stash pop 取出最近一次暂存代码 再次查看已经没有差异 ","date":"2023年 11月16日","objectID":"/git-stash/:0:0","tags":["git"],"title":"git stash 使用","uri":"/git-stash/"},{"categories":["系统运维"],"content":"最近运行平均时间较长SQL查询 select * from (select sa.SQL_TEXT, sa.SQL_FULLTEXT, sa.EXECUTIONS \"执行次数\", round(sa.ELAPSED_TIME / 1000000, 2) \"总执行时间\", round(sa.ELAPSED_TIME / 1000000 / sa.EXECUTIONS, 2) \"平均执行时间\", sa.COMMAND_TYPE, sa.PARSING_USER_ID \"用户ID\", u.username \"用户名\", sa.HASH_VALUE from v$sqlarea sa left join all_users u on sa.PARSING_USER_ID = u.user_id where sa.EXECUTIONS \u003e 0 order by (sa.ELAPSED_TIME / sa.EXECUTIONS) desc) where rownum \u003c= 50; ","date":"2023年 11月16日","objectID":"/oracle-run-sql/:1:0","tags":["oracle","sql"],"title":"oracle最近运行SQL查询","uri":"/oracle-run-sql/"},{"categories":["系统运维"],"content":"最近运行SQL查询 SELECT * from V$SQL WHERE sql_id IS NOT NULL; ","date":"2023年 11月16日","objectID":"/oracle-run-sql/:2:0","tags":["oracle","sql"],"title":"oracle最近运行SQL查询","uri":"/oracle-run-sql/"},{"categories":["编程问题"],"content":" // 一次性写入 if err := os.WriteFile(\"file.txt\", []byte(\"Hello GOSAMPLES!\"), 0666); err != nil { log.Fatal(err) } // 逐行写入 package main import ( \"log\" \"os\" ) var lines = []string{ \"Go\", \"is\", \"the\", \"best\", \"programming\", \"language\", \"in\", \"the\", \"world\", } func main() { // create file f, err := os.Create(\"file.txt\") if err != nil { log.Fatal(err) } // remember to close the file defer f.Close() for _, line := range lines { _, err := f.WriteString(line + \"\\n\") if err != nil { log.Fatal(err) } } } // 写入byte package main import ( \"log\" \"os\" ) var bytes = []byte{ 0x47, // G 0x4f, // O 0x20, // \u003cspace\u003e 0x20, // \u003cspace\u003e 0x20, // \u003cspace\u003e 0x50, // P 0x4c, // L 0x45, // E 0x53, // S } var additionalBytes = []byte{ 0x53, // S 0x41, // A 0x4d, // M } func main() { // create file f, err := os.Create(\"file.txt\") if err != nil { log.Fatal(err) } // remember to close the file defer f.Close() // write bytes to the file _, err = f.Write(bytes) if err != nil { log.Fatal(err) } // write additional bytes to the file, start at index 2 _, err = f.WriteAt(additionalBytes, 2) if err != nil { log.Fatal(err) } } // 缓冲方式写入 package main import ( \"bufio\" \"log\" \"os\" ) var lines = []string{ \"Go\", \"is\", \"the\", \"best\", \"programming\", \"language\", \"in\", \"the\", \"world\", } func main() { // create file f, err := os.Create(\"file.txt\") if err != nil { log.Fatal(err) } // remember to close the file defer f.Close() // create new buffer buffer := bufio.NewWriter(f) for _, line := range lines { _, err := buffer.WriteString(line + \"\\n\") if err != nil { log.Fatal(err) } } // flush buffered data to the file if err := buffer.Flush(); err != nil { log.Fatal(err) } } ","date":"2023年 11月16日","objectID":"/golang-write/:0:0","tags":["golang","文件系统"],"title":"golang的文件写入","uri":"/golang-write/"},{"categories":["系统运维"],"content":"假设存在两个表： create table darcy1( ima01 varchar(40), ima02 varchar(40), ima021 varchar(200) ); create table darcy2( ima01 varchar(40), ima02 varchar(40) ) 运行下面代码不会出错，darcy2虽然没有ima021字段，但是SQL能匹配到darcy1有ima021字段，所以ima021字段被省略了。 select * from darcy1 where (ima01,ima02,ima021) in ( select ima01,ima02,ima021 from darcy2 where ima01 like 'M%' ) 以上代码结果等价于： select * from darcy1 where (ima01,ima02) in ( select ima01,ima02from darcy2 where ima01 like 'M%' ) 所以嵌套的时候，如果两个表字段有可能重复，子查询中请尽量用表名.字段的形式。 ","date":"2023年 11月16日","objectID":"/sql-in-error/:0:0","tags":["oracle","sql","运维"],"title":"in嵌套错误字段问题","uri":"/sql-in-error/"},{"categories":["软件安装"],"content":" graph LR subgraph 6.服务端验证完毕: end subgraph 5.客户端发送验证后资料: j[\"客户端\"]--私钥解密--\u003ek[\"服务端\"] end subgraph 4.客户端请求服务段验证: e[\"服务端\"]--随机数据--\u003eg[\"客户端\"] end subgraph 3.客户端访问客户端: d[\"客户端\"]--\u003ef[\"服务端\"] end subgraph 2.私钥放到服务端: h[\"私钥\"]--放置--\u003ei[\"服务端\"] end subgraph 1.产生密钥: a[\"客户端\"]--生成--\u003eb[\"公钥\"] a--生成--\u003ec[\"私钥\"] end 产生ssh密钥 #产生ssh密钥 \u003e ssh-keygen Generating public/private rsa key pair. Enter file in which to save the key (C:\\Users\\darcy/.ssh/id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in C:\\Users\\darcy/.ssh/id_rsa Your public key has been saved in C:\\Users\\darcy/.ssh/id_rsa.pub The key fingerprint is: SHA256:NezN7f4OQQ183iHvX17y6QLijOTIDoWzhozgvo/tras darcy@darcy The key's randomart image is: +---[RSA 3072]----+ | .. | | . ..+.| | + +o+| | . o + o .o| |. o . S . o + | |= . + . . . ..oo| |.+ +. + + . . o+=| |. + oo o o o o+| | E=*+o ++o| +----[SHA256]-----+ ","date":"2023年 11月16日","objectID":"/ssh/:0:0","tags":["ssh","远程开发"],"title":"ssh密钥使用","uri":"/ssh/"},{"categories":["编程问题"],"content":"excel汇入 DEFINE xlapp INTEGER DEFINE xlwb INTEGER MAIN DEFINE result INTEGER DEFINE str STRING --initialization of global variables LET xlapp = -1 LET xlwb = -1 --first, we must create an Instance of an Excel Application CALL ui.Interface.frontCall(\"WinCOM\", \"CreateInstance\", [\"Excel.Application\"], [xlapp]) CALL CheckError(xlapp, __LINE__) --then adding a Workbook to the current document CALL ui.interface.frontCall(\"WinCOM\", \"CallMethod\", [xlapp, \"WorkBooks.Add\"], [xlwb]) CALL CheckError(xlwb, __LINE__) --then, setting it to be visible CALL ui.interface.frontCall(\"WinCOM\", \"SetProperty\", [xlapp, \"Visible\", true], [result]) CALL CheckError(result, __LINE__) --then CALL SetProperty to set the value of the cell CALL ui.Interface.frontCall(\"WinCOM\", \"SetProperty\", [xlwb, 'activesheet.Range(\"A1\").Value', \"foo\"],[result]) CALL CheckError(result, __LINE__) --then CALL GetProperty to check the value again CALL ui.Interface.frontCall(\"WinCOM\", \"GetProperty\", [xlwb, 'activesheet.Range(\"A1\").Value'], [str]) CALL CheckError(str, __LINE__) DISPLAY \"content of the cell is: \" || str --then Free the memory on the client side CALL freeMemory() END MAIN FUNCTION freeMemory() DEFINE res INTEGER IF xlwb != -1 THEN CALL ui.Interface.frontCall(\"WinCOM\",\"ReleaseInstance\", [xlwb], [res] ) END IF IF xlapp != -1 THEN CALL ui.Interface.frontCall(\"WinCOM\",\"ReleaseInstance\", [xlapp], [res] ) END IF END FUNCTION FUNCTION checkError(res, lin) DEFINE res INTEGER DEFINE lin INTEGER DEFINE mess STRING IF res = -1 THEN DISPLAY \"COM Error for call at line:\", lin CALL ui.Interface.frontCall(\"WinCOM\",\"GetError\",[],[mess]) DISPLAY mess --let's release the memory on the GDC side CALL freeMemory() DISPLAY \"Exit with COM Error.\" EXIT PROGRAM (-1) END IF END FUNCTION ","date":"2023年 11月16日","objectID":"/tiptop-gp-%D0%B3%D0%BF%D1%80/:1:0","tags":["bdl","tiptop gp"],"title":"tiptop gp 常用的函数和编程方式","uri":"/tiptop-gp-%D0%B3%D0%BF%D1%80/"},{"categories":["编程问题"],"content":"列表报错 CALL s_showmsg_init() LOOP CALL s_errmsg(field,date,msg,'mfg0301',1) END CALL s_showmsg() ","date":"2023年 11月16日","objectID":"/tiptop-gp-%D0%B3%D0%BF%D1%80/:2:0","tags":["bdl","tiptop gp"],"title":"tiptop gp 常用的函数和编程方式","uri":"/tiptop-gp-%D0%B3%D0%BF%D1%80/"},{"categories":["编程问题"],"content":"动态设置下拉框 DECLARE t310_curoqaud03 CURSOR FOR SELECT UNIQUE azi01 FROM azi_file LET g_oqaud03_cmbo = \"\" FOREACH t310_curoqaud03 INTO g_azi01 IF cl_null(g_oqaud03_cmbo) THEN LET g_oqaud03_cmbo=g_azi01 ELSE LET g_oqaud03_cmbo=g_oqaud03_cmbo CLIPPED,\",\",g_azi01 CLIPPED END IF END FOREACH CALL cl_set_combo_items(\"oqaud03\",g_oqaud03_cmbo,g_oqaud03_cmbo) ","date":"2023年 11月16日","objectID":"/tiptop-gp-%D0%B3%D0%BF%D1%80/:3:0","tags":["bdl","tiptop gp"],"title":"tiptop gp 常用的函数和编程方式","uri":"/tiptop-gp-%D0%B3%D0%BF%D1%80/"},{"categories":["编程问题"],"content":"字段显示颜色 ","date":"2023年 11月16日","objectID":"/tiptop-gp-%D0%B3%D0%BF%D1%80/:4:0","tags":["bdl","tiptop gp"],"title":"tiptop gp 常用的函数和编程方式","uri":"/tiptop-gp-%D0%B3%D0%BF%D1%80/"},{"categories":["编程问题"],"content":"表单 cl_chg_comp_att(ps_fields,ps_atts,ps_values) CALL cl_chg_comp_att(\"tc_ioa01,tc_ioa02\",\"color\",\"cyan\") 不支持的属性修改 LET lwin_curr = ui.Window.getCurrent() LET lfrm_curr = lwin_curr.getForm() LET lnode_item = lfrm_curr.findNode(\"FormField\",\"formonly.tc_ioa01\") LET lnode_child = lnode_item.getFirstChild() CALL lnode_child.setAttribute(\"underline\",true) 表格 利用DIALOG.setCellAttributes()函数 新增一个和单身数组字段一致的数组 DEFINE g_oeb_color DYNAMIC ARRAY OF RECORD c01 STRING,c02 STRING, c03 STRING,c04 STRING, c05 STRING,c06 STRING, c07 STRING,c08 STRING, c09 STRING,c10 STRING, c11 STRING,c12 STRING END RECORD 每笔单独设置颜色 LET g_oeb_color[2].c10 =\"red\" 在DISPLAY中设置显示模式 BEFORE DISPLAY ##显示之前设置属性 CALL DIALOG.setCellAttributes(g_oeb_color) ","date":"2023年 11月16日","objectID":"/tiptop-gp-%D0%B3%D0%BF%D1%80/:4:1","tags":["bdl","tiptop gp"],"title":"tiptop gp 常用的函数和编程方式","uri":"/tiptop-gp-%D0%B3%D0%BF%D1%80/"},{"categories":["ERP问题","系统运维"],"content":"环境变量FGLSQLDEBUG 此环境变量，控制运行程序时，后台显示日期的等级。 最高等级为9，取消设置命令为unset FGLSQLDEBUG 将环境变量设置为9 后，运行我们想要分析效能的程序，并将日志记录到文件中。 export FGLSQLDEBUG=9 exe2 p_zz \u003e\u003e p_zz.log 2\u003e\u00261 ","date":"2023年 11月16日","objectID":"/tiptop-%D0%B7%D1%89/:1:0","tags":["bdl","debug","sql","oracle"],"title":"tiptop 效能排查","uri":"/tiptop-%D0%B7%D1%89/"},{"categories":["ERP问题","系统运维"],"content":"分析日志 日志除了人工分析，系统也有作业可以分析。 $FGLRUN $DS4GL/bin/fgldebug.42r $FGLRUN $UTL/fbin/42m/T100SQLDebug.42r p_zz.log 即可打开效能分析工具 💡 r.r2d+和r.h分别时tiptop gp和T100的效能功能。如果环境没问题，直接运行 r.r2d+/r.h p_zz 也可以直接分析效能 ","date":"2023年 11月16日","objectID":"/tiptop-%D0%B7%D1%89/:2:0","tags":["bdl","debug","sql","oracle"],"title":"tiptop 效能排查","uri":"/tiptop-%D0%B7%D1%89/"},{"categories":["系统运维"],"content":"清楚查询缓存 ALTER SYSTEM FLUSH SHARED_POOL; ALTER SYSTEM FLUSH BUFFER_CACHE; ALTER SYSTEM FLUSH GLOBAL CONTEXT; ","date":"2023年 11月16日","objectID":"/oracle-%D0%B3%D1%8E%D1%8Bsql/:1:0","tags":["oracle","sql","运维"],"title":"oracle 常用命令与SQL","uri":"/oracle-%D0%B3%D1%8E%D1%8Bsql/"},{"categories":["系统运维"],"content":"分析表结构 --① 分析表的所有字段，所有索引，所有索引字段。其中：① = ② analyze table student compute statistics; --② 分析表的所有字段，所有索引，所有索引字段。其中：① = ② analyze table student compute statistics for table for all indexes for all columns; --③ 只分析所有有索引的字段 analyze table student compute statistics for table for all indexes for all indexed columns; --④ 抽样估算法 analyze table student estimate statistics sample 20 percent; --⑤ 删除分析数据 analyze table student delete statistics; analyze table student delete statistics for table for all indexes for all indexed columns; --查看表的统计信息 select table_name,num_rows,blocks,empty_blocks from user_tables where table_name='student'; analyze table glaq_t compute statistics; ","date":"2023年 11月16日","objectID":"/oracle-%D0%B3%D1%8E%D1%8Bsql/:2:0","tags":["oracle","sql","运维"],"title":"oracle 常用命令与SQL","uri":"/oracle-%D0%B3%D1%8E%D1%8Bsql/"},{"categories":["系统运维"],"content":"优化器 优先查询前25笔 SELECT /*+ FIRST_ROWS(25) */ employee_id, department_id FROM hr.employees WHERE department_id \u003e 50; 强制走索引 SELECT /*+index(a)*/ * FROM sfb_file LEFT JOIN sfa_file ON sfa01= sfb01 LEFT JOIN ima_file a ON a.ima01 = sfb05 LEFT JOIN ima_file b ON b.ima01 = sfa03 LEFT JOIN ima_file c ON c.ima01 = sfa27 ","date":"2023年 11月16日","objectID":"/oracle-%D0%B3%D1%8E%D1%8Bsql/:3:0","tags":["oracle","sql","运维"],"title":"oracle 常用命令与SQL","uri":"/oracle-%D0%B3%D1%8E%D1%8Bsql/"},{"categories":["系统运维"],"content":"查询被删除的表 select object_name,original_name,partition_name,type,ts_name,createtime,droptime from recyclebin; 恢复删除的表 flashback table test_drop to before drop;或 flashback table \"BIN$hgcd$0\" to before drop; ","date":"2023年 11月16日","objectID":"/oracle-%D0%B3%D1%8E%D1%8Bsql/:4:0","tags":["oracle","sql","运维"],"title":"oracle 常用命令与SQL","uri":"/oracle-%D0%B3%D1%8E%D1%8Bsql/"},{"categories":["系统运维"],"content":"清理临时表空间 set linesize 132; set pagesize 0; set timing off; spool drop_tables.sql; SELECT 'drop table '||OWNER||'.'||TABLE_name||' purge;' FROM dba_tables WHERE tablespace_name='TEMPTABS'; spool off; @drop_tables.sql; ","date":"2023年 11月16日","objectID":"/oracle-%D0%B3%D1%8E%D1%8Bsql/:5:0","tags":["oracle","sql","运维"],"title":"oracle 常用命令与SQL","uri":"/oracle-%D0%B3%D1%8E%D1%8Bsql/"},{"categories":["系统运维"],"content":"查询某个时间之前的表状态（闪回） select * from sfb_file as of timestamp to_timestamp('2021-09-22 15:30:00','yyyy-mm-dd hh24:mi:ss') ","date":"2023年 11月16日","objectID":"/oracle-%D0%B3%D1%8E%D1%8Bsql/:6:0","tags":["oracle","sql","运维"],"title":"oracle 常用命令与SQL","uri":"/oracle-%D0%B3%D1%8E%D1%8Bsql/"},{"categories":["系统运维"],"content":"查询单个table占用磁盘空间 select * from ( select t.tablespace_name,t.owner, t.segment_name, t.segment_type, sum(t.bytes / 1024 / 1024) mb from dba_segments t where t.segment_type='TABLE' AND tablespace_name ='TEMPTABS' group by t.tablespace_name,t.OWNER, t.segment_name, t.segment_type ) t order by t.mb desc; ","date":"2023年 11月16日","objectID":"/oracle-%D0%B3%D1%8E%D1%8Bsql/:7:0","tags":["oracle","sql","运维"],"title":"oracle 常用命令与SQL","uri":"/oracle-%D0%B3%D1%8E%D1%8Bsql/"},{"categories":["系统运维"],"content":"在备份中仅恢复部分表 准备号dmp备份文件 建立临时测试库 sqlplus system/manager@topprod create user test1 identified by test1 default tablespace dbs1; grant connect,resource to test1; commit; 恢复表 imp system/manager@topprod file=/u3/backup/Wed/exp_KT_20210203.dmp fromuser=kt touser=test1 tables=gen_file,eci_file ","date":"2023年 11月16日","objectID":"/oracle-%D0%B3%D1%8E%D1%8Bsql/:8:0","tags":["oracle","sql","运维"],"title":"oracle 常用命令与SQL","uri":"/oracle-%D0%B3%D1%8E%D1%8Bsql/"},{"categories":["系统运维"],"content":"增加表空间 命令查询表空间是否足够 查询表空间文件位置 增加合适大小表空间文件 alter tablespace xx add datafile 'xxx.dbf' size 4G; ","date":"2023年 11月16日","objectID":"/oracle-%D0%B3%D1%8E%D1%8Bsql/:9:0","tags":["oracle","sql","运维"],"title":"oracle 常用命令与SQL","uri":"/oracle-%D0%B3%D1%8E%D1%8Bsql/"},{"categories":["编程问题"],"content":"递归查询 -- 递归遍历查询 select t.*, LEVEL from area_test t start with name = '郑州市' connect by prior id = parent_id; select bmb09 from bmb_file where bmb04 \u003c= ? and ( bmb05 is null or bmb05 \u003e ? ) start with bmb01 in ( select oeb04 from oeb_file where oeb01 = ? ) connect by prior bmb03 = bmb01 ","date":"2023年 11月16日","objectID":"/oracle-sql%D1%8F%D0%B8/:1:0","tags":["sql","oracle"],"title":"oracle sql语法","uri":"/oracle-sql%D1%8F%D0%B8/"},{"categories":["编程问题"],"content":"pivot 列转行 WITH a AS (SELECT 'darcy' na, '语文' ke, 23 score FROM dual), b AS (SELECT 'tom', '语文', 23 FROM dual), c AS (SELECT 'darcy', '数学', 24 FROM dual), d AS (SELECT * FROM a UNION ALL SELECT * FROM b UNION ALL SELECT * FROM c) SELECT na, 语文, 数学 FROM (SELECT na, ke, score FROM d) PIVOT (SUM(score) FOR ke IN('语文' AS 语文, '数学' AS 数学)); ","date":"2023年 11月16日","objectID":"/oracle-sql%D1%8F%D0%B8/:2:0","tags":["sql","oracle"],"title":"oracle sql语法","uri":"/oracle-sql%D1%8F%D0%B8/"},{"categories":["编程问题"],"content":"unpivot 行转列 WITH a AS (SELECT 'darcy' na, '90' 语文, '80' 数学, '87' 英语 FROM dual) SELECT na, ke, score FROM a UNPIVOT(score for ke in(语文, 数学, 英语)) ","date":"2023年 11月16日","objectID":"/oracle-sql%D1%8F%D0%B8/:3:0","tags":["sql","oracle"],"title":"oracle sql语法","uri":"/oracle-sql%D1%8F%D0%B8/"},{"categories":["编程问题"],"content":"keep 聚合的基础上再取最值 SELECT tc_bmj03,tc_bmj04,MAX(tc_bmj01) KEEP(dense_rank LAST order BY tc_bmj09) max01 FROM tc_bmj_file WHERE tc_bmj11 ='2' GROUP BY tc_bmj03,tc_bmj04 ","date":"2023年 11月16日","objectID":"/oracle-sql%D1%8F%D0%B8/:4:0","tags":["sql","oracle"],"title":"oracle sql语法","uri":"/oracle-sql%D1%8F%D0%B8/"},{"categories":["编程问题"],"content":"over 分析 语法：rank()/dense_rank over(partition by A order by B) over是一种分析函数，根据字段A对结果进行分区，在各分区内按照字段进行排序； over不能单独使用，需要与row_number()，rank()和dense_rank，lag()和lead(),sum()等配合使用 说明： over()在什么条件之上 partition by 按哪个字段划分组 order by 按哪个字段排序 注意： 使用rank()/dense_rank() 时，必须要带order by否则非法 rank(): 跳跃排序，如果有两个第一级时，接下来就是第三级 dense_rank(): 连续排序，如果有两个第一级时，接下来仍然是第二级 SELECT fan01, fan03, fan04, fan15, dense_rank() OVER(PARTITION BY fan01 ORDER BY fan03 DESC, fan04 DESC) r FROM fan_file WHERE fan041 IN ('0', '1') AND fan05 IN ('1', '2') AND fan01 = 'FLYG200001' ","date":"2023年 11月16日","objectID":"/oracle-sql%D1%8F%D0%B8/:5:0","tags":["sql","oracle"],"title":"oracle sql语法","uri":"/oracle-sql%D1%8F%D0%B8/"},{"categories":["编程问题"],"content":"lag 偏移函数 可以查询上几条数据,下几条数据,适合查上下站资料 SELECT fan01, fan03, fan04, fan15, LAG(fan03||fan04) OVER (ORDER BY fan03 DESC ,fan04 DESC) a1, LAG(fan03||fan04,2,0) OVER (ORDER BY fan03,fan04) a2 FROM fan_file WHERE fan041 IN ('0', '1') AND fan05 IN ('1', '2') AND fan01 = 'FLYG200001' ORDER BY fan03,fan04 ","date":"2023年 11月16日","objectID":"/oracle-sql%D1%8F%D0%B8/:6:0","tags":["sql","oracle"],"title":"oracle sql语法","uri":"/oracle-sql%D1%8F%D0%B8/"},{"categories":["编程问题"],"content":"instr 字符串匹配函数 SELECT INSTR('123456789','2'), -- 返回：2 INSTR('123456654321','66'), -- 返回：6 INSTR('123456654321','66',6), -- 返回：6 INSTR('123456654321','66',8), -- 返回：0 INSTR('11223344','2',1,2), -- 返回：4 INSTR('11223344','2',2,3), -- 返回：0 INSTR('11223344','2',-1,2), -- 返回：3 INSTR('11223344','2',-6,1), -- 返回：3 INSTR('11223344','2',-6,2) -- 返回：0 FROM DUAL ; ","date":"2023年 11月16日","objectID":"/oracle-sql%D1%8F%D0%B8/:7:0","tags":["sql","oracle"],"title":"oracle sql语法","uri":"/oracle-sql%D1%8F%D0%B8/"},{"categories":["编程问题"],"content":"listagg 聚合为一条数据 LISTAGG(字段名,',') WITHIN GROUP( ORDER BY 字段名) listagg(字段名,',') within GROUP (order by 字段名) over (partition by 字段名) rank with temp as( select 500 population, '中国' nation ,'江苏' city from dual union all select 1500 population, '中国' nation ,'上海' city from dual union all select 500 population, '中国' nation ,'北京' city from dual union all select 1000 population, '美国' nation ,'纽约' city from dual union all select 500 population, '美国' nation ,'波士顿' city from dual union all select 500 population, '日本' nation ,'东京' city from dual ) select population, nation, city, listagg(city,',') within GROUP (order by city) over (partition by nation) rank from temp ","date":"2023年 11月16日","objectID":"/oracle-sql%D1%8F%D0%B8/:8:0","tags":["sql","oracle"],"title":"oracle sql语法","uri":"/oracle-sql%D1%8F%D0%B8/"},{"categories":null,"content":"关于 LoveIt","date":"2019年 08月02日","objectID":"/about/","tags":null,"title":"关于 LoveIt","uri":"/about/"},{"categories":null,"content":"@darcyjoven 👋 🔭 I’m currently working at Forewin a company in suzhou.jiangsu.China 💬 Ask me about golang,fgl genero,ERP,javascript… 🖥 My blog site is: darcy’s blog 📘 My book site is: darcy’s book 📫 How to reach me: ✉ darcy_joven@live.com 📱 wechat:darcy_joven ","date":"2019年 08月02日","objectID":"/about/:0:0","tags":null,"title":"关于 LoveIt","uri":"/about/"}]